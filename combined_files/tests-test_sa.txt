# tests/test_sa/conftest.py
import os
import sys
import pytest
from pathlib import Path
from sqlalchemy.sql import text
from datetime import datetime, UTC, timedelta

# Add debugging information
print("\nCurrent working directory:", os.getcwd())
print("__file__:", __file__)

# Calculate project root
project_root = str(Path(__file__).parent.parent.parent)
print("Project root path:", project_root)
print("Current sys.path:", sys.path)

# Add project root to Python path
if project_root not in sys.path:
    sys.path.insert(0, project_root)
    print("Updated sys.path:", sys.path)

try:
    from sqlalchemy.orm import Session
    print("Successfully imported sqlalchemy.orm")
except ImportError as e:
    print("Failed to import sqlalchemy.orm:", str(e))
    
try:
    from core.sa.models import (
        Base, Book, Author, Genre, Series, BookSeries,
        BookAuthor, BookGenre, BookSimilar, User, BookUser
    )
    print("Successfully imported core.sa.models")
except ImportError as e:
    print("Failed to import core.sa.models:", str(e))
    
try:
    from core.sa.database import Database
    print("Successfully imported core.sa.database")
except ImportError as e:
    print("Failed to import core.sa.database:", str(e))

@pytest.fixture(scope="session")
def test_db_path(tmp_path_factory):
    """Create a temporary directory for the test database."""
    test_dir = tmp_path_factory.mktemp("test_db")
    return str(test_dir / "test_books.db")

@pytest.fixture(scope="session")
def database(test_db_path):
    """Create a test database instance"""
    db = Database(db_path=test_db_path)
    
    # Drop all tables and recreate schema
    Base.metadata.drop_all(db.engine)
    Base.metadata.create_all(db.engine)
    
    yield db
    
    # Clean up the test database file after all tests
    try:
        os.remove(test_db_path)
    except OSError:
        pass  # Ignore errors if file doesn't exist

@pytest.fixture(autouse=True)
def cleanup_db(db_session):
    """Clean up database tables before each test"""
    # Delete all data from tables in reverse order of dependencies
    db_session.execute(text("DELETE FROM book_similar"))
    db_session.execute(text("DELETE FROM book_series"))
    db_session.execute(text("DELETE FROM book_genre"))
    db_session.execute(text("DELETE FROM book_author"))
    db_session.execute(text("DELETE FROM book_user"))
    db_session.execute(text("DELETE FROM library"))
    db_session.execute(text("DELETE FROM series"))
    db_session.execute(text("DELETE FROM book"))
    db_session.execute(text("DELETE FROM author"))
    db_session.execute(text("DELETE FROM genre"))
    db_session.execute(text("DELETE FROM user"))
    db_session.commit()
    yield
    # Clean up after test as well
    db_session.rollback()

@pytest.fixture(scope="function")
def db_session(database):
    """Create a new database session for a test"""
    session: Session = database._SessionFactory()
    try:
        yield session
    finally:
        session.close()

@pytest.fixture
def sample_author(db_session):
    """Create a sample author for testing."""
    author = Author(
        goodreads_id="author_1",
        name="Test Author",
        bio="Test author description",
        image_url="http://example.com/author.jpg"
    )
    db_session.add(author)
    db_session.commit()
    return author

@pytest.fixture
def sample_genre(db_session):
    """Create a sample genre for testing."""
    genre = Genre(
        name="Test Genre"
    )
    db_session.add(genre)
    db_session.commit()
    return genre

@pytest.fixture
def sample_series(db_session):
    """Create a sample series for testing."""
    series = Series(
        goodreads_id="series_1",
        title="Test Series"
    )
    db_session.add(series)
    db_session.commit()
    return series

@pytest.fixture
def sample_book(db_session):
    """Create a sample book for testing."""
    book = Book(
        goodreads_id="book_1",
        work_id="work_1",
        title="Test Book",
        published_date=datetime.now(UTC),
        language="English",
        pages=200,
        isbn="1234567890",
        goodreads_rating=4.5,
        goodreads_votes=1000,
        description="Test book description"
    )
    db_session.add(book)
    db_session.commit()
    return book

@pytest.fixture
def sample_book_with_relationships(db_session, sample_book, sample_author, sample_genre, sample_series):
    """Create a book with all relationships for testing."""
    # Add author relationship
    book_author = BookAuthor(
        work_id=sample_book.work_id,
        author_id=sample_author.goodreads_id,
        role="author"
    )
    db_session.add(book_author)
    
    # Add genre relationship
    book_genre = BookGenre(
        work_id=sample_book.work_id,
        genre_id=sample_genre.id
    )
    db_session.add(book_genre)
    
    # Create book-series relationship with order
    book_series = BookSeries(
        work_id=sample_book.work_id,
        series_id=sample_series.goodreads_id,
        series_order=1.0
    )
    db_session.add(book_series)
    
    # Add similar book
    similar_book = Book(
        goodreads_id="book_2",
        work_id="work_2",
        title="Similar Test Book",
        published_date=datetime.now(UTC)
    )
    db_session.add(similar_book)
    
    # Add similar book relationship
    book_similar = BookSimilar(
        work_id=sample_book.work_id,
        similar_work_id=similar_book.work_id
    )
    db_session.add(book_similar)
    
    db_session.commit()
    return sample_book

@pytest.fixture
def multiple_books(db_session, sample_genre, sample_series):
    """Create multiple books with relationships for testing."""
    books = []
    for i in range(1, 21):  # Create 20 books
        # Create a unique author for each book
        author = Author(
            goodreads_id=f"author_{i}",
            name=f"Test Author {i}",
            bio=f"Test author {i} description",
            image_url=f"http://example.com/author_{i}.jpg"
        )
        db_session.add(author)
        
        book = Book(
            goodreads_id=f"book_{i}",
            work_id=f"work_{i}",
            title=f"Test Book {i}",
            published_date=datetime.now(UTC),
            goodreads_rating=4.0 + (i % 10) / 10,  # Ratings from 4.0 to 4.9
            goodreads_votes=i * 100
        )
        db_session.add(book)
        
        # Add author relationship
        book_author = BookAuthor(
            work_id=book.work_id,
            author_id=author.goodreads_id,
            role="author"
        )
        db_session.add(book_author)
        
        # Add genre relationship
        book_genre = BookGenre(
            work_id=book.work_id,
            genre_id=sample_genre.id
        )
        db_session.add(book_genre)
        
        # Add to series with order
        book_series = BookSeries(
            work_id=book.work_id,
            series_id=sample_series.goodreads_id,
            series_order=float(i)
        )
        db_session.add(book_series)
        
        books.append(book)
    
    db_session.commit()
    return books

@pytest.fixture
def sample_user(db_session):
    """Create a sample user for testing."""
    user = User(name="Test User")
    db_session.add(user)
    db_session.commit()
    return user

@pytest.fixture
def sample_user_with_books(db_session, sample_user, sample_book):
    """Create a user with book relationships for testing."""
    book_user = BookUser(
        work_id=sample_book.work_id,
        user_id=sample_user.id,
        status="reading",
        source="test",
        started_at=datetime.now(UTC)
    )
    db_session.add(book_user)
    db_session.commit()
    return sample_user

@pytest.fixture
def multiple_users_with_books(db_session, multiple_books):
    """Create multiple users with book relationships for testing."""
    users = []
    statuses = ["reading", "completed", "want_to_read"]
    
    for i in range(5):  # Create 5 users
        user = User(name=f"Test User {i}")
        db_session.add(user)
        db_session.commit()
        
        # Associate each user with some books
        for j, book in enumerate(multiple_books[:3]):  # First 3 books
            book_user = BookUser(
                work_id=book.work_id,
                user_id=user.id,
                status=statuses[j % len(statuses)],
                source="test",
                started_at=datetime.now(UTC) - timedelta(days=i)
            )
            if book_user.status == "completed":
                book_user.finished_at = datetime.now(UTC)
            db_session.add(book_user)
        
        users.append(user)
    
    db_session.commit()
    return users


# tests\test_sa\explore_data.py

import os
import sys
from pathlib import Path

# Add project root to Python path
project_root = str(Path(__file__).parent.parent.parent)
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from core.sa.database import Database
from core.sa.repositories.author import AuthorRepository
from core.sa.repositories.book import BookRepository
from core.sa.repositories.genre import GenreRepository
from core.sa.repositories.series import SeriesRepository
from sqlalchemy import text, inspect

def main():
    # Connect to your real database
    db_path = "books.db"
    print(f"\nTrying to connect to database at: {os.path.abspath(db_path)}")
    db = Database(db_path)
    
    try:
        # List all tables in the database
        inspector = inspect(db.engine)
        existing_tables = inspector.get_table_names()
        print("\nExisting tables in database:", existing_tables)
        
        # For each table, show its columns
        for table in existing_tables:
            columns = inspector.get_columns(table)
            print(f"\nColumns in {table}:")
            for col in columns:
                print(f"- {col['name']} ({col['type']})")
        
        # Initialize repositories
        author_repo = AuthorRepository(db.session)
        book_repo = BookRepository(db.session)
        genre_repo = GenreRepository(db.session)
        series_repo = SeriesRepository(db.session)
        
        # Check if tables exist and have data
        print("\nChecking table counts:")
        for table in existing_tables:
            result = db.session.execute(text(f"SELECT COUNT(*) FROM {table}")).scalar()
            print(f"- {table}: {result} records")
            
        # Example queries - uncomment and modify as needed
        
        # Search authors
        print("\nSearching authors:")
        authors = author_repo.search_authors("")  # Empty query to get all authors
        print(f"Found {len(authors)} authors")
        for author in authors[:5]:  # Show first 5
            print(f"- {author.name} (ID: {author.goodreads_id})")
        
        # Search books
        print("\nSearching books:")
        books = book_repo.search_books("")  # Empty query to get all books
        print(f"Found {len(books)} books")
        for book in books[:5]:  # Show first 5
            print(f"- {book.title} (ID: {book.goodreads_id})")
            
        # Get genres
        print("\nListing genres:")
        genres = genre_repo.search_genres("")  # Empty query to get all genres
        print(f"Found {len(genres)} genres")
        for genre in genres[:5]:  # Show first 5
            print(f"- {genre.name}")
            
        # Get series
        print("\nListing series:")
        series_list = series_repo.search_series("")  # Empty query to get all series
        print(f"Found {len(series_list)} series")
        for series in series_list[:5]:  # Show first 5
            print(f"- {series.title} (ID: {series.goodreads_id})")
            
        # Example of more specific queries
        print("\nExample specific queries:")
        
        # Get books by rating
        highly_rated = book_repo.get_books_with_rating_above(4.5)
        print(f"Found {len(highly_rated)} books rated above 4.5")
        
        # Get recent books
        recent_books = book_repo.get_recent_books(limit=5)
        print("\nRecent books:")
        for book in recent_books:
            print(f"- {book.title}")
            
        # Get prolific authors
        prolific = author_repo.get_prolific_authors(min_books=10)
        print(f"\nFound {len(prolific)} authors with 10+ books")
        
    except Exception as e:
        print(f"\nError: {str(e)}")
        import traceback
        traceback.print_exc()
    finally:
        db.close_session()

if __name__ == "__main__":
    main() 


# tests/test_sa/README.md
# SQLAlchemy Integration Tests

These tests verify that SQLAlchemy can correctly:
1. Connect to the existing database
2. Map the existing schema to SQLAlchemy models
3. Perform queries using the repository pattern

## Running Tests

From the project root:
```bash
pytest tests/test_sa
```

To see SQL queries:
```bash
pytest tests/test_sa -s --log-cli-level=DEBUG
```

## Test Structure

- `conftest.py`: Test configuration and fixtures
- `test_models.py`: Tests for SQLAlchemy model mappings
- `test_repositories/`: Tests for repository implementations


# tests/test_sa/test_models.py
import pytest
from core.sa.models import (
    Base, Book, Author, Genre, Series, BookSeries,
    BookAuthor, BookGenre, BookSimilar, User, BookUser
)

def test_book_model_exists(db_session, sample_book):
    """Test that we can query the book table"""
    # Get book count
    count = db_session.query(Book).count()
    assert count > 0, "Book table should not be empty"
    
    # Get one book and check its structure
    book = db_session.query(Book).first()
    assert book is not None
    assert hasattr(book, 'title')
    assert hasattr(book, 'goodreads_id')
    assert hasattr(book, 'work_id')

def test_book_relationships(db_session, sample_book_with_relationships):
    """Test that book relationships are properly configured"""
    # Get a book with its relationships
    book = db_session.query(Book).filter_by(work_id="work_1").first()
    assert book is not None
    
    # Check authors through association model
    assert len(book.book_authors) > 0, "Book should have at least one book_author relationship"
    book_author = book.book_authors[0]
    assert hasattr(book_author, 'role')
    assert book_author.author.name == "Test Author"
    
    # Check convenience relationship
    assert len(book.authors) > 0, "Book should have at least one author"
    author = book.authors[0]
    assert hasattr(author, 'name')
    assert hasattr(author, 'goodreads_id')
    
    # Check genres through association model
    assert len(book.book_genres) > 0, "Book should have at least one book_genre relationship"
    book_genre = book.book_genres[0]
    assert book_genre.genre.name == "Test Genre"
    
    # Check convenience relationship
    assert len(book.genres) > 0, "Book should have at least one genre"
    genre = book.genres[0]
    assert hasattr(genre, 'name')
    
    # Check series through association model
    assert len(book.book_series) > 0, "Book should have at least one book_series relationship"
    book_series = book.book_series[0]
    assert hasattr(book_series, 'series_order')
    assert book_series.series.title == "Test Series"
    
    # Check convenience relationship
    assert len(book.series) > 0, "Book should have at least one series"
    series = book.series[0]
    assert hasattr(series, 'title')
    
    # Check similar books through association model
    assert len(book.similar_to) > 0, "Book should have at least one similar book relationship"
    book_similar = book.similar_to[0]
    assert book_similar.similar_book.title == "Similar Test Book"

def test_author_relationships(db_session, sample_book_with_relationships):
    """Test that author relationships are properly configured"""
    author = db_session.query(Author).filter_by(goodreads_id="author_1").first()
    assert author is not None
    
    # Check books through association model
    assert len(author.book_authors) > 0, "Author should have at least one book_author relationship"
    book_author = author.book_authors[0]
    assert hasattr(book_author, 'role')
    assert book_author.book.title == "Test Book"
    
    # Check convenience relationship
    assert len(author.books) > 0, "Author should have at least one book"
    book = author.books[0]
    assert hasattr(book, 'title')
    assert hasattr(book, 'work_id')

def test_genre_relationships(db_session, sample_book_with_relationships):
    """Test that genre relationships are properly configured"""
    genre = db_session.query(Genre).filter_by(name="Test Genre").first()
    assert genre is not None
    
    # Check books through association model
    assert len(genre.book_genres) > 0, "Genre should have at least one book_genre relationship"
    book_genre = genre.book_genres[0]
    assert book_genre.book.title == "Test Book"
    
    # Check convenience relationship
    assert len(genre.books) > 0, "Genre should have at least one book"
    book = genre.books[0]
    assert hasattr(book, 'title')
    assert hasattr(book, 'work_id')

def test_series_relationships(db_session, sample_book_with_relationships):
    """Test that series relationships are properly configured"""
    series = db_session.query(Series).filter_by(goodreads_id="series_1").first()
    assert series is not None
    
    # Check books through association model
    assert len(series.book_series) > 0, "Series should have at least one book_series relationship"
    book_series = series.book_series[0]
    assert hasattr(book_series, 'series_order')
    assert book_series.book.title == "Test Book"
    
    # Check convenience relationship
    assert len(series.books) > 0, "Series should have at least one book"
    book = series.books[0]
    assert hasattr(book, 'title')
    assert hasattr(book, 'work_id')


# tests/test_sa/test_schema.py
import pytest
from core.sa.models import Book, Author, Genre, Series
from tests.test_sa.utils import print_table_schema, print_sample_data, compare_model_to_db


def test_book_schema(db_session):
    """Test Book model matches database schema"""
    print("\nBook Schema:")
    print_table_schema(db_session, "book")
    print_sample_data(db_session, "book", limit=2)
    
    differences = compare_model_to_db(db_session, Book)
    assert not differences, f"Schema differences found: {differences}"

def test_author_schema(db_session):
    """Test Author model matches database schema"""
    print("\nAuthor Schema:")
    print_table_schema(db_session, "author")
    print_sample_data(db_session, "author", limit=2)
    
    differences = compare_model_to_db(db_session, Author)
    assert not differences, f"Schema differences found: {differences}"

def test_genre_schema(db_session):
    """Test Genre model matches database schema"""
    print("\nGenre Schema:")
    print_table_schema(db_session, "genre")
    print_sample_data(db_session, "genre", limit=2)
    
    differences = compare_model_to_db(db_session, Genre)
    assert not differences, f"Schema differences found: {differences}"

def test_series_schema(db_session):
    """Test Series model matches database schema"""
    print("\nSeries Schema:")
    print_table_schema(db_session, "series")
    print_sample_data(db_session, "series", limit=2)
    
    differences = compare_model_to_db(db_session, Series)
    assert not differences, f"Schema differences found: {differences}"


# tests/test_sa/utils.py
from typing import List, Dict, Any, Optional
from sqlalchemy import inspect, text
from sqlalchemy.engine import Engine
from sqlalchemy.orm import Session

class DBInspector:
    def __init__(self, session: Session):
        self.session = session
        self.engine = session.get_bind()
        self.inspector = inspect(self.engine)

    def get_table_info(self, table_name: str) -> Dict[str, Any]:
        """Get detailed information about a specific table"""
        columns = self.inspector.get_columns(table_name)
        pk = self.inspector.get_pk_constraint(table_name)
        fks = self.inspector.get_foreign_keys(table_name)
        indexes = self.inspector.get_indexes(table_name)

        return {
            'columns': columns,
            'primary_key': pk,
            'foreign_keys': fks,
            'indexes': indexes
        }

    def get_all_tables(self) -> List[str]:
        """Get list of all tables in database"""
        return self.inspector.get_table_names()

    def count_rows(self, table_name: str) -> int:
        """Get row count for a table"""
        result = self.session.execute(text(f"SELECT COUNT(*) FROM {table_name}"))
        return result.scalar()

    def get_schema_sql(self, table_name: str) -> str:
        """Get CREATE TABLE SQL for a table"""
        result = self.session.execute(
            text(f"SELECT sql FROM sqlite_master WHERE type='table' AND name=:name"),
            {'name': table_name}
        )
        return result.scalar() or ''

    def get_sample_data(self, table_name: str, limit: int = 5) -> List[Dict[str, Any]]:
        """Get sample rows from a table"""
        result = self.session.execute(
            text(f"SELECT * FROM {table_name} LIMIT :limit"),
            {'limit': limit}
        )
        
        # Convert row results to dictionaries using keys from result
        return [
            {key: value for key, value in zip(result.keys(), row)}
            for row in result
        ]

    def describe_table(self, table_name: str) -> str:
        """Get a human-readable description of a table"""
        info = self.get_table_info(table_name)
        
        description = [f"\nTable: {table_name}"]
        description.append("\nColumns:")
        for col in info['columns']:
            nullable = "NULL" if col['nullable'] else "NOT NULL"
            default = f"DEFAULT {col['default']}" if col['default'] is not None else ""
            description.append(f"  - {col['name']}: {col['type']} {nullable} {default}")

        if info['primary_key']['constrained_columns']:
            description.append("\nPrimary Key:")
            description.append(f"  {', '.join(info['primary_key']['constrained_columns'])}")

        if info['foreign_keys']:
            description.append("\nForeign Keys:")
            for fk in info['foreign_keys']:
                description.append(
                    f"  - {', '.join(fk['constrained_columns'])} -> "
                    f"{fk['referred_table']}({', '.join(fk['referred_columns'])})"
                )

        if info['indexes']:
            description.append("\nIndexes:")
            for idx in info['indexes']:
                unique = "UNIQUE " if idx['unique'] else ""
                description.append(
                    f"  - {unique}INDEX {idx['name']} ON ({', '.join(idx['column_names'])})"
                )

        row_count = self.count_rows(table_name)
        description.append(f"\nRow Count: {row_count}")

        return "\n".join(description)

def print_table_schema(session: Session, table_name: str):
    """Print detailed schema information for a table"""
    inspector = DBInspector(session)
    print(inspector.describe_table(table_name))
    
def print_sample_data(session: Session, table_name: str, limit: int = 5):
    """Print sample rows from a table"""
    inspector = DBInspector(session)
    samples = inspector.get_sample_data(table_name, limit)
    print(f"\nSample data from {table_name} (showing {len(samples)} rows):")
    for row in samples:
        print(row)

def compare_model_to_db(session: Session, model_class) -> List[str]:
    """Compare SQLAlchemy model to actual database table"""
    differences = []
    inspector = DBInspector(session)
    table_name = model_class.__tablename__
    db_info = inspector.get_table_info(table_name)
    
    # Get model columns
    mapper = inspect(model_class)
    model_columns = {c.key: c for c in mapper.columns}
    
    # Compare columns
    db_columns = {c['name']: c for c in db_info['columns']}
    
    # Check for columns in model but not in db
    for col_name in model_columns:
        if col_name not in db_columns:
            differences.append(f"Column '{col_name}' exists in model but not in database")
            
    # Check for columns in db but not in model
    for col_name in db_columns:
        if col_name not in model_columns:
            differences.append(f"Column '{col_name}' exists in database but not in model")
            
    return differences


# tests/test_sa/__init__.py
# Make tests/test_sa a package

