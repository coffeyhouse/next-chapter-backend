# tests/test_sa/conftest.py
import os
import sys
import pytest
from pathlib import Path

# Add debugging information
print("\nCurrent working directory:", os.getcwd())
print("__file__:", __file__)

# Calculate project root
project_root = str(Path(__file__).parent.parent.parent)
print("Project root path:", project_root)
print("Current sys.path:", sys.path)

# Add project root to Python path
if project_root not in sys.path:
    sys.path.insert(0, project_root)
    print("Updated sys.path:", sys.path)

try:
    from sqlalchemy.orm import Session
    print("Successfully imported sqlalchemy.orm")
except ImportError as e:
    print("Failed to import sqlalchemy.orm:", str(e))
    
try:
    from core.sa.models import Base
    print("Successfully imported core.sa.models")
except ImportError as e:
    print("Failed to import core.sa.models:", str(e))
    
try:
    from core.sa.database import Database
    print("Successfully imported core.sa.database")
except ImportError as e:
    print("Failed to import core.sa.database:", str(e))

@pytest.fixture(scope="session")
def database():
    """Create a test database instance"""
    return Database(db_path="books.db")

@pytest.fixture(scope="function")
def db_session(database):
    """Create a new database session for a test"""
    session: Session = database._SessionFactory()
    try:
        yield session
    finally:
        session.close()


# tests/test_sa/README.md
# SQLAlchemy Integration Tests

These tests verify that SQLAlchemy can correctly:
1. Connect to the existing database
2. Map the existing schema to SQLAlchemy models
3. Perform queries using the repository pattern

## Running Tests

From the project root:
```bash
pytest tests/test_sa
```

To see SQL queries:
```bash
pytest tests/test_sa -s --log-cli-level=DEBUG
```

## Test Structure

- `conftest.py`: Test configuration and fixtures
- `test_models.py`: Tests for SQLAlchemy model mappings
- `test_repositories/`: Tests for repository implementations


# tests/test_sa/test_models.py
import pytest
from core.sa.models import Book, Author, Genre, Series

def test_book_model_exists(db_session):
    """Test that we can query the book table"""
    # Get book count
    count = db_session.query(Book).count()
    assert count > 0, "Book table should not be empty"
    
    # Get one book and check its structure
    book = db_session.query(Book).first()
    assert book is not None
    assert hasattr(book, 'title')
    assert hasattr(book, 'goodreads_id')
    assert hasattr(book, 'work_id')

def test_book_relationships(db_session):
    """Test that book relationships are properly configured"""
    # Get a book that has authors and genres
    book = db_session.query(Book).join(Book.authors).join(Book.genres).first()
    assert book is not None
    
    # Check authors
    assert len(book.authors) > 0, "Book should have at least one author"
    author = book.authors[0]
    assert hasattr(author, 'name')
    assert hasattr(author, 'goodreads_id')
    
    # Check genres
    if book.genres:  # Some books might not have genres
        genre = book.genres[0]
        assert hasattr(genre, 'name')


# tests/test_sa/test_schema.py
import pytest
from core.sa.models import Book, Author, Genre, Series
from tests.test_sa.utils import print_table_schema, print_sample_data, compare_model_to_db


def test_book_schema(db_session):
    """Test Book model matches database schema"""
    print("\nBook Schema:")
    print_table_schema(db_session, "book")
    print_sample_data(db_session, "book", limit=2)
    
    differences = compare_model_to_db(db_session, Book)
    assert not differences, f"Schema differences found: {differences}"

def test_author_schema(db_session):
    """Test Author model matches database schema"""
    print("\nAuthor Schema:")
    print_table_schema(db_session, "author")
    print_sample_data(db_session, "author", limit=2)
    
    differences = compare_model_to_db(db_session, Author)
    assert not differences, f"Schema differences found: {differences}"

def test_genre_schema(db_session):
    """Test Genre model matches database schema"""
    print("\nGenre Schema:")
    print_table_schema(db_session, "genre")
    print_sample_data(db_session, "genre", limit=2)
    
    differences = compare_model_to_db(db_session, Genre)
    assert not differences, f"Schema differences found: {differences}"

def test_series_schema(db_session):
    """Test Series model matches database schema"""
    print("\nSeries Schema:")
    print_table_schema(db_session, "series")
    print_sample_data(db_session, "series", limit=2)
    
    differences = compare_model_to_db(db_session, Series)
    assert not differences, f"Schema differences found: {differences}"


# tests/test_sa/utils.py
from typing import List, Dict, Any, Optional
from sqlalchemy import inspect, text
from sqlalchemy.engine import Engine
from sqlalchemy.orm import Session

class DBInspector:
    def __init__(self, session: Session):
        self.session = session
        self.engine = session.get_bind()
        self.inspector = inspect(self.engine)

    def get_table_info(self, table_name: str) -> Dict[str, Any]:
        """Get detailed information about a specific table"""
        columns = self.inspector.get_columns(table_name)
        pk = self.inspector.get_pk_constraint(table_name)
        fks = self.inspector.get_foreign_keys(table_name)
        indexes = self.inspector.get_indexes(table_name)

        return {
            'columns': columns,
            'primary_key': pk,
            'foreign_keys': fks,
            'indexes': indexes
        }

    def get_all_tables(self) -> List[str]:
        """Get list of all tables in database"""
        return self.inspector.get_table_names()

    def count_rows(self, table_name: str) -> int:
        """Get row count for a table"""
        result = self.session.execute(text(f"SELECT COUNT(*) FROM {table_name}"))
        return result.scalar()

    def get_schema_sql(self, table_name: str) -> str:
        """Get CREATE TABLE SQL for a table"""
        result = self.session.execute(
            text(f"SELECT sql FROM sqlite_master WHERE type='table' AND name=:name"),
            {'name': table_name}
        )
        return result.scalar() or ''

    def get_sample_data(self, table_name: str, limit: int = 5) -> List[Dict[str, Any]]:
        """Get sample rows from a table"""
        result = self.session.execute(
            text(f"SELECT * FROM {table_name} LIMIT :limit"),
            {'limit': limit}
        )
        
        # Convert row results to dictionaries using keys from result
        return [
            {key: value for key, value in zip(result.keys(), row)}
            for row in result
        ]

    def describe_table(self, table_name: str) -> str:
        """Get a human-readable description of a table"""
        info = self.get_table_info(table_name)
        
        description = [f"\nTable: {table_name}"]
        description.append("\nColumns:")
        for col in info['columns']:
            nullable = "NULL" if col['nullable'] else "NOT NULL"
            default = f"DEFAULT {col['default']}" if col['default'] is not None else ""
            description.append(f"  - {col['name']}: {col['type']} {nullable} {default}")

        if info['primary_key']['constrained_columns']:
            description.append("\nPrimary Key:")
            description.append(f"  {', '.join(info['primary_key']['constrained_columns'])}")

        if info['foreign_keys']:
            description.append("\nForeign Keys:")
            for fk in info['foreign_keys']:
                description.append(
                    f"  - {', '.join(fk['constrained_columns'])} -> "
                    f"{fk['referred_table']}({', '.join(fk['referred_columns'])})"
                )

        if info['indexes']:
            description.append("\nIndexes:")
            for idx in info['indexes']:
                unique = "UNIQUE " if idx['unique'] else ""
                description.append(
                    f"  - {unique}INDEX {idx['name']} ON ({', '.join(idx['column_names'])})"
                )

        row_count = self.count_rows(table_name)
        description.append(f"\nRow Count: {row_count}")

        return "\n".join(description)

def print_table_schema(session: Session, table_name: str):
    """Print detailed schema information for a table"""
    inspector = DBInspector(session)
    print(inspector.describe_table(table_name))
    
def print_sample_data(session: Session, table_name: str, limit: int = 5):
    """Print sample rows from a table"""
    inspector = DBInspector(session)
    samples = inspector.get_sample_data(table_name, limit)
    print(f"\nSample data from {table_name} (showing {len(samples)} rows):")
    for row in samples:
        print(row)

def compare_model_to_db(session: Session, model_class) -> List[str]:
    """Compare SQLAlchemy model to actual database table"""
    differences = []
    inspector = DBInspector(session)
    table_name = model_class.__tablename__
    db_info = inspector.get_table_info(table_name)
    
    # Get model columns
    mapper = inspect(model_class)
    model_columns = {c.key: c for c in mapper.columns}
    
    # Compare columns
    db_columns = {c['name']: c for c in db_info['columns']}
    
    # Check for columns in model but not in db
    for col_name in model_columns:
        if col_name not in db_columns:
            differences.append(f"Column '{col_name}' exists in model but not in database")
            
    # Check for columns in db but not in model
    for col_name in db_columns:
        if col_name not in model_columns:
            differences.append(f"Column '{col_name}' exists in database but not in model")
            
    return differences


# tests/test_sa/__init__.py
# Make tests/test_sa a package

