# core/database/base.py
import sqlite3
from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

class BaseDB:
    def __init__(self, db_path: str):
        self.db_path = db_path
        
    def _get_connection(self) -> sqlite3.Connection:
        """Get database connection with foreign keys enabled"""
        conn = sqlite3.connect(self.db_path)
        conn.execute("PRAGMA foreign_keys = ON")
        return conn
        
    def upsert(self, table: str, data: Dict[str, Any], key_field: str) -> tuple[bool, bool]:
        """
        Insert or update record
        
        Args:
            table: Table name
            data: Dictionary of field names and values
            key_field: Primary key field name
            
        Returns:
            tuple[bool, bool]: (success, was_updated)
        """
        try:
            now = datetime.now().isoformat()
            
            # Clean data (handle empty values)
            clean_data = {}
            for k, v in data.items():
                if v == "":  # Empty string
                    clean_data[k] = None
                elif isinstance(v, (list, dict)) and not v:  # Empty list/dict
                    clean_data[k] = None
                else:
                    clean_data[k] = v
            
            # Check if record exists
            with self._get_connection() as conn:
                cursor = conn.execute(
                    f"SELECT * FROM {table} WHERE {key_field} = ?",
                    (clean_data[key_field],)
                )
                existing = cursor.fetchone()
            
            if existing:
                # Preserve created_at for existing record
                cursor = conn.execute(
                    f"SELECT created_at FROM {table} WHERE {key_field} = ?",
                    (clean_data[key_field],)
                )
                result = cursor.fetchone()
                if result:
                    clean_data['created_at'] = result[0]
            else:
                # Set created_at for new record
                if 'created_at' not in clean_data:
                    clean_data['created_at'] = now
                    
            # Always update updated_at
            clean_data['updated_at'] = now
            
            # Prepare SQL
            fields = list(clean_data.keys())
            placeholders = ','.join(['?'] * len(fields))
            update_set = ','.join([
                f"{f}=excluded.{f}" 
                for f in fields 
                if f != key_field
            ])
            
            sql = f"""
                INSERT INTO {table} ({','.join(fields)})
                VALUES ({placeholders})
                ON CONFLICT({key_field}) 
                DO UPDATE SET {update_set}
                WHERE {table}.{key_field} = excluded.{key_field}
            """
            
            # Execute upsert
            with self._get_connection() as conn:
                conn.execute(sql, list(clean_data.values()))
                return True, existing is not None
                
        except Exception as e:
            logger.error(f"Error upserting to {table}: {str(e)}")
            return False, False
            
    def get_by_id(self, table: str, id_value: Any, id_field: str = 'id') -> Optional[Dict[str, Any]]:
        """Get single record by ID"""
        try:
            with self._get_connection() as conn:
                cursor = conn.execute(
                    f"SELECT * FROM {table} WHERE {id_field} = ?",
                    (id_value,)
                )
                row = cursor.fetchone()
                if row:
                    return dict(zip([col[0] for col in cursor.description], row))
                return None
                
        except Exception as e:
            logger.error(f"Error getting {table} by ID: {str(e)}")
            return None
            
    def get_all(
        self, 
        table: str,
        conditions: Optional[Dict[str, Any]] = None,
        order_by: Optional[str] = None,
        limit: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """Get multiple records with optional filtering"""
        try:
            sql = f"SELECT * FROM {table}"
            params = []
            
            if conditions:
                where_clauses = []
                for field, value in conditions.items():
                    if value is None:
                        where_clauses.append(f"{field} IS NULL")
                    else:
                        where_clauses.append(f"{field} = ?")
                        params.append(value)
                if where_clauses:
                    sql += " WHERE " + " AND ".join(where_clauses)
                    
            if order_by:
                sql += f" ORDER BY {order_by}"
                
            if limit:
                sql += f" LIMIT {limit}"
                
            with self._get_connection() as conn:
                cursor = conn.execute(sql, params)
                return [
                    dict(zip([col[0] for col in cursor.description], row))
                    for row in cursor.fetchall()
                ]
                
        except Exception as e:
            logger.error(f"Error getting records from {table}: {str(e)}")
            return []
            
    def execute_query(self, sql: str, params: tuple = ()) -> List[Dict[str, Any]]:
        """Execute custom query"""
        try:
            with self._get_connection() as conn:
                cursor = conn.execute(sql, params)
                return [
                    dict(zip([col[0] for col in cursor.description], row))
                    for row in cursor.fetchall()
                ]
                
        except Exception as e:
            logger.error(f"Error executing query: {str(e)}")
            return []


# core\database\goodreads.py

from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
from pathlib import Path
import sqlite3
from .base import BaseDB
from .schema import init_db
from ..scrapers.book_scraper import BookScraper
import logging

logger = logging.getLogger(__name__)

class GoodreadsDB(BaseDB):
    def __init__(self, db_path: str = "books.db"):
        super().__init__(db_path)
        self._ensure_db_exists()
        self.book_scraper = BookScraper(scrape=True)
    
    def _ensure_db_exists(self):
        if not Path(self.db_path).exists():
            init_db(self.db_path)

    def import_calibre_books(self, calibre_path: str, limit: Optional[int] = None) -> tuple[int, int]:
        """Import books from Calibre that aren't already in the library table"""
        try:
            # Get existing Goodreads IDs from library table
            with self._get_connection() as conn:
                cursor = conn.execute("SELECT goodreads_id FROM library")
                existing_ids = {row[0] for row in cursor.fetchall()}
            
            # Get books from Calibre
            with sqlite3.connect(calibre_path) as calibre_conn:
                query = """
                    SELECT 
                        books.id AS calibre_id,
                        books.title,
                        gr.val AS goodreads_id,
                        isbn.val AS isbn,
                        warren_read.value AS warren_last_read,
                        ruth_read.value AS ruth_last_read
                    FROM books
                    LEFT JOIN identifiers gr 
                        ON gr.book = books.id 
                        AND gr.type = 'goodreads'
                    LEFT JOIN identifiers isbn
                        ON isbn.book = books.id 
                        AND isbn.type = 'isbn'
                    LEFT JOIN custom_column_6 warren_read
                        ON warren_read.book = books.id
                    LEFT JOIN custom_column_14 ruth_read
                        ON ruth_read.book = books.id
                    WHERE gr.val IS NOT NULL
                """
                
                cursor = calibre_conn.execute(query)
                books = cursor.fetchall()
                
                # Filter out existing books and apply limit
                new_books = [
                    book for book in books 
                    if book[2] not in existing_ids  # index 2 is goodreads_id
                ]
                if limit:
                    new_books = new_books[:limit]
                
                print(f"Found {len(new_books)} new books to import")
                
                processed = 0
                imported = 0
                
                for book in new_books:
                    calibre_data = dict(zip(
                        ['calibre_id', 'title', 'goodreads_id', 'isbn', 
                         'warren_last_read', 'ruth_last_read'], 
                        book
                    ))
                    
                    if self._import_single_book(calibre_data):
                        imported += 1
                        print(f"Successfully imported {calibre_data['title']} ({imported}/{len(new_books)})")
                    else:
                        print(f"Failed to import {calibre_data['title']}")
                    processed += 1
                
                return processed, imported
                
        except Exception as e:
            print(f"Error importing from Calibre: {e}")
            return 0, 0

    def _import_single_book(self, calibre_data: Dict[str, Any]) -> bool:
        """Import a single book and all its related data"""
        try:
            # Scrape Goodreads data
            goodreads_id = calibre_data['goodreads_id']
            goodreads_data = self.book_scraper.scrape_book(goodreads_id)
            if not goodreads_data:
                print(f"Failed to scrape Goodreads data for ID: {goodreads_id}")
                return False

            with self._get_connection() as conn:
                conn.execute("BEGIN")
                try:
                    # Import main book data
                    if not self._import_book_data(conn, calibre_data, goodreads_data):
                        raise Exception("Failed to import book data")

                    # Import authors
                    if not self._import_authors(conn, goodreads_id, goodreads_data.get('authors', [])):
                        raise Exception("Failed to import authors")

                    # Import series
                    if not self._import_series(conn, goodreads_id, goodreads_data.get('series', [])):
                        raise Exception("Failed to import series")

                    # Import genres
                    if not self._import_genres(conn, goodreads_id, goodreads_data.get('genres', [])):
                        raise Exception("Failed to import genres")

                    conn.execute("COMMIT")
                    return True

                except Exception as e:
                    conn.execute("ROLLBACK")
                    print(f"Transaction failed: {e}")
                    return False

        except Exception as e:
            print(f"Error importing book: {e}")
            return False

    def _import_book_data(self, conn: sqlite3.Connection, calibre_data: Dict[str, Any], 
                         goodreads_data: Dict[str, Any]) -> bool:
        """Import main book data"""
        try:
            now = datetime.now().isoformat()
            
            # Prepare books record
            book = {
                'goodreads_id': calibre_data['goodreads_id'],
                'title': goodreads_data['title'],
                'work_id': goodreads_data['work_id'],
                'published_date': goodreads_data['published_date'],
                'published_state': goodreads_data['published_state'],
                'language': goodreads_data['language'],
                'calibre_id': calibre_data['calibre_id'],
                'pages': goodreads_data['pages'],
                'isbn': calibre_data['isbn'] or goodreads_data['isbn'],
                'goodreads_rating': goodreads_data['goodreads_rating'],
                'goodreads_votes': goodreads_data['goodreads_votes'],
                'description': goodreads_data['description'],
                'image_url': goodreads_data['image_url'],
                'source': 'library',
                'hidden': False,
                'created_at': now,
                'updated_at': now
            }
            
            # Insert into books table
            fields = list(book.keys())
            placeholders = ','.join(['?'] * len(fields))
            values = [book[field] for field in fields]
            
            conn.execute(f"""
                INSERT INTO book ({','.join(fields)})
                VALUES ({placeholders})
                ON CONFLICT(goodreads_id) DO UPDATE SET
                {','.join(f"{field}=excluded.{field}" for field in fields if field != 'goodreads_id')}
            """, values)
            
            # Insert into library table
            library = {
                'title': calibre_data['title'],
                'calibre_id': calibre_data['calibre_id'],
                'goodreads_id': calibre_data['goodreads_id'],
                'isbn': calibre_data['isbn'],
                'created_at': now,
                'updated_at': now
            }
            
            fields = list(library.keys())
            placeholders = ','.join(['?'] * len(fields))
            values = [library[field] for field in fields]
            
            conn.execute(f"""
                INSERT INTO library ({','.join(fields)})
                VALUES ({placeholders})
                ON CONFLICT(goodreads_id) DO UPDATE SET
                {','.join(f"{field}=excluded.{field}" for field in fields if field != 'goodreads_id')}
            """, values)
            
            return True
            
        except Exception as e:
            print(f"Error importing book data: {e}")
            return False

    def _import_authors(self, conn: sqlite3.Connection, book_id: str, authors: List[Dict[str, Any]]) -> bool:
        """Import authors and author-book relationships"""
        try:
            now = datetime.now().isoformat()
            
            for author in authors:
                # Insert author
                author_data = {
                    'goodreads_id': author['goodreads_id'],
                    'name': author['name'],
                    'created_at': now,
                    'updated_at': now
                }
                
                fields = list(author_data.keys())
                placeholders = ','.join(['?'] * len(fields))
                values = [author_data[field] for field in fields]
                
                conn.execute(f"""
                    INSERT INTO author ({','.join(fields)})
                    VALUES ({placeholders})
                    ON CONFLICT(goodreads_id) DO UPDATE SET
                    {','.join(f"{field}=excluded.{field}" for field in fields if field != 'goodreads_id')}
                """, values)
                
                # Insert author-book relationship
                relation_data = {
                    'book_id': book_id,
                    'author_id': author['goodreads_id'],
                    'role': author['role'],
                    'created_at': now,
                    'updated_at': now
                }
                
                fields = list(relation_data.keys())
                placeholders = ','.join(['?'] * len(fields))
                values = [relation_data[field] for field in fields]
                
                conn.execute(f"""
                    INSERT INTO book_author ({','.join(fields)})
                    VALUES ({placeholders})
                    ON CONFLICT(book_id, author_id) DO UPDATE SET
                    {','.join(f"{field}=excluded.{field}" for field in fields if field not in ['book_id', 'author_id'])}
                """, values)
            
            return True
            
        except Exception as e:
            print(f"Error importing authors: {e}")
            return False

    def _import_series(self, conn: sqlite3.Connection, book_id: str, series_list: List[Dict[str, Any]]) -> bool:
        """Import series and book-series relationships"""
        try:
            now = datetime.now().isoformat()
            
            for series in series_list:
                if not series['goodreads_id']:
                    continue
                    
                # Insert series
                series_data = {
                    'goodreads_id': series['goodreads_id'],
                    'title': series['name'],
                    'created_at': now,
                    'updated_at': now
                }
                
                fields = list(series_data.keys())
                placeholders = ','.join(['?'] * len(fields))
                values = [series_data[field] for field in fields]
                
                conn.execute(f"""
                    INSERT INTO series ({','.join(fields)})
                    VALUES ({placeholders})
                    ON CONFLICT(goodreads_id) DO UPDATE SET
                    {','.join(f"{field}=excluded.{field}" for field in fields if field != 'goodreads_id')}
                """, values)
                
                # Insert book-series relationship
                relation_data = {
                    'book_id': book_id,
                    'series_id': series['goodreads_id'],
                    'series_order': series['order'],
                    'created_at': now,
                    'updated_at': now
                }
                
                fields = list(relation_data.keys())
                placeholders = ','.join(['?'] * len(fields))
                values = [relation_data[field] for field in fields]
                
                conn.execute(f"""
                    INSERT INTO book_series ({','.join(fields)})
                    VALUES ({placeholders})
                    ON CONFLICT(book_id, series_id) DO UPDATE SET
                    {','.join(f"{field}=excluded.{field}" for field in fields if field not in ['book_id', 'series_id'])}
                """, values)
            
            return True
            
        except Exception as e:
            print(f"Error importing series: {e}")
            return False

    def _import_genres(self, conn: sqlite3.Connection, book_id: str, genres: List[Dict[str, Any]]) -> bool:
        """Import genres and book-genre relationships"""
        try:
            now = datetime.now().isoformat()
            
            for genre in genres:
                # First ensure genre exists and get its ID
                cursor = conn.execute(
                    "SELECT id FROM genre WHERE name = ?",
                    (genre['name'],)
                )
                result = cursor.fetchone()
                
                if result:
                    genre_id = result[0]
                else:
                    cursor = conn.execute(
                        """
                        INSERT INTO genre (name, created_at, updated_at)
                        VALUES (?, ?, ?)
                        """,
                        (genre['name'], now, now)
                    )
                    genre_id = cursor.lastrowid
                
                # Insert book-genre relationship
                relation_data = {
                    'book_id': book_id,
                    'genre_id': genre_id,
                    'created_at': now,
                    'updated_at': now
                }
                
                fields = list(relation_data.keys())
                placeholders = ','.join(['?'] * len(fields))
                values = [relation_data[field] for field in fields]
                
                conn.execute(f"""
                    INSERT INTO book_genre ({','.join(fields)})
                    VALUES ({placeholders})
                    ON CONFLICT(book_id, genre_id) DO UPDATE SET
                    {','.join(f"{field}=excluded.{field}" for field in fields if field not in ['book_id', 'genre_id'])}
                """, values)
            
            return True
            
        except Exception as e:
            print(f"Error importing genres: {e}")
            return False


# core\database\schema.py

from pathlib import Path
import sqlite3

def init_db(db_path: str = "books.db"):
    """Initialize SQLite database with required schema"""
    db_file = Path(db_path)
    db_file.parent.mkdir(parents=True, exist_ok=True)
    
    with sqlite3.connect(db_path) as conn:
        conn.execute("PRAGMA foreign_keys = ON")
        
        conn.executescript("""
            -- Books table (main entity)
            CREATE TABLE IF NOT EXISTS book (
                goodreads_id TEXT PRIMARY KEY,
                work_id TEXT NOT NULL,
                title TEXT NOT NULL,
                published_date TEXT,
                published_state TEXT,
                language TEXT,
                calibre_id INTEGER,
                pages INTEGER,
                isbn TEXT,
                goodreads_rating REAL,
                goodreads_votes INTEGER,
                description TEXT,
                image_url TEXT,
                source TEXT,
                hidden BOOLEAN DEFAULT FALSE,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                last_synced_at TEXT
            );
            
            -- Library table (unique concept)
            CREATE TABLE IF NOT EXISTS library (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                calibre_id INTEGER,
                goodreads_id TEXT UNIQUE,
                work_id TEXT NOT NULL,
                isbn TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                last_synced_at TEXT,
                FOREIGN KEY (work_id) REFERENCES book(work_id)
            );
            
            -- Series table (main entity)
            CREATE TABLE IF NOT EXISTS series (
                goodreads_id TEXT PRIMARY KEY,
                title TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                last_synced_at TEXT
            );
            
            -- Book-Series relationship
            CREATE TABLE IF NOT EXISTS book_series (
                work_id TEXT,
                series_id TEXT,
                series_order REAL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                PRIMARY KEY (work_id, series_id),
                FOREIGN KEY (work_id) REFERENCES book(work_id),
                FOREIGN KEY (series_id) REFERENCES series(goodreads_id)
            );
            
            -- Authors table (main entity)
            CREATE TABLE IF NOT EXISTS author (
                goodreads_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                bio TEXT,
                image_url TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                last_synced_at TEXT
            );
            
            -- Book-Author relationship
            CREATE TABLE IF NOT EXISTS book_author (
                work_id TEXT,
                author_id TEXT,
                role TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                PRIMARY KEY (work_id, author_id),
                FOREIGN KEY (work_id) REFERENCES book(work_id),
                FOREIGN KEY (author_id) REFERENCES author(goodreads_id)
            );
            
            -- Genres table (main entity)
            CREATE TABLE IF NOT EXISTS genre (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL UNIQUE,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            );
            
            -- Book-Genre relationship
            CREATE TABLE IF NOT EXISTS book_genre (
                work_id TEXT,
                genre_id INTEGER,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                PRIMARY KEY (work_id, genre_id),
                FOREIGN KEY (work_id) REFERENCES book(work_id),
                FOREIGN KEY (genre_id) REFERENCES genre(id)
            );
            
            -- Awards table (main entity)
            CREATE TABLE IF NOT EXISTS award (
                goodreads_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            );
            
            -- Book-Award relationship
            CREATE TABLE IF NOT EXISTS book_award (
                work_id TEXT,
                award_id TEXT,
                category TEXT,
                year INTEGER,
                designation TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                PRIMARY KEY (work_id, award_id),
                FOREIGN KEY (work_id) REFERENCES book(work_id),
                FOREIGN KEY (award_id) REFERENCES award(goodreads_id)
            );
            
            -- Users table (main entity)
            CREATE TABLE IF NOT EXISTS user (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            );
            
            -- Book-User relationship
            CREATE TABLE IF NOT EXISTS book_user (
                work_id TEXT,
                user_id INTEGER,
                status TEXT NOT NULL,
                source TEXT,
                started_at TEXT,
                finished_at TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                PRIMARY KEY (work_id, user_id),
                FOREIGN KEY (work_id) REFERENCES book(work_id),
                FOREIGN KEY (user_id) REFERENCES user(id)
            );
            
            -- Book-Similar relationship
            CREATE TABLE IF NOT EXISTS book_similar (
                work_id TEXT,
                similar_work_id TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                PRIMARY KEY (work_id, similar_work_id),
                FOREIGN KEY (work_id) REFERENCES book(work_id),
                FOREIGN KEY (similar_work_id) REFERENCES book(work_id)
            );
        """)
        
        # Create performance indexes
        conn.executescript("""
            CREATE INDEX IF NOT EXISTS idx_book_title ON book(title);
            CREATE INDEX IF NOT EXISTS idx_book_work_id ON book(work_id);
            CREATE INDEX IF NOT EXISTS idx_library_calibre_id ON library(calibre_id);
            CREATE INDEX IF NOT EXISTS idx_library_isbn ON library(isbn);
            CREATE INDEX IF NOT EXISTS idx_library_work_id ON library(work_id);
            CREATE INDEX IF NOT EXISTS idx_series_title ON series(title);
            CREATE INDEX IF NOT EXISTS idx_author_name ON author(name);
            CREATE INDEX IF NOT EXISTS idx_book_user_status ON book_user(status);
            CREATE INDEX IF NOT EXISTS idx_book_user_finished ON book_user(finished_at);
        """)

if __name__ == "__main__":
    init_db()


# core/database/__init__.py
from .goodreads import GoodreadsDB

__all__ = ['GoodreadsDB']

