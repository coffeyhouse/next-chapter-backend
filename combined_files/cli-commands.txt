# cli\commands\author.py

import click
from core.database import GoodreadsDB
from core.scrapers.author_scraper import AuthorScraper
from core.scrapers.author_books_scraper import AuthorBooksScraper

@click.group()
def author():
    """Author management commands"""
    pass

@author.command()
@click.option('--db-path', '--db', default="books.db", help='Path to books database')
@click.option('--days', default=30, help='Sync authors not updated in this many days')
@click.option('--limit', default=None, type=int, help='Limit number of authors to sync')
def sync(db_path: str, days: int, limit: int):
    """Sync unsynced authors and import their books"""
    click.echo(f"\nSyncing authors not updated in {days} days")
    if limit:
        click.echo(f"Limited to {limit} authors")
    
    db = GoodreadsDB(db_path)
    processed, imported = db.sync_authors(days, limit)
    
    click.echo(f"\nProcessed {processed} authors")
    click.echo(f"Imported {imported} new books")


# cli\commands\chain.py

import click
from core.database import GoodreadsDB

@click.command()
@click.option('--db-path', '--db', default="books.db", help='Path to the books database')
@click.option('--calibre-path', default="C:/path/to/calibre/metadata.db", help='Path to Calibre metadata.db')
@click.option('--limit', default=None, type=int, help='Limit number of books for each operation')
def chain(db_path: str, calibre_path: str, limit: int):
    """
    Chain several CLI operations:
      1. Import books from the Calibre library.
      2. Sync similar books (for books with source "library").
      3. Sync series.

    This command will run the three tasks sequentially.
    """
    db = GoodreadsDB(db_path)

    click.echo("\n=== Starting Library Import ===")
    lib_processed, lib_imported = db.import_calibre_books(calibre_path, limit)
    click.echo(f"Library Import: Processed {lib_processed} books, Imported {lib_imported} books.\n")

    click.echo("=== Starting Similar Sync ===")
    sim_processed, sim_imported = db.sync_similar(source="library", limit=limit)
    click.echo(f"Similar Sync: Processed {sim_processed} books, Imported {sim_imported} similar relationships.\n")

    click.echo("=== Starting Series Sync ===")
    ser_processed, ser_imported = db.sync_series(limit=limit)
    click.echo(f"Series Sync: Processed {ser_processed} series, Imported {ser_imported} books from series.\n")

if __name__ == '__main__':
    chain()



# cli\commands\dev.py

import click
from pathlib import Path
import os

@click.group()
def dev():
    """Development helper commands"""
    pass

@dev.command()
@click.option('--output', default="directory_structure.txt", help='Output file path')
def structure(output: str):
    """Output directory structure to file"""
    click.echo(f"\nGenerating directory structure to: {output}")
    
    EXCLUDE_DIRS = {
        '.git', '__pycache__', 'backend',
        'author_photos', 'book_covers', 'exported_html'
    }
    DATA_FOLDER_ONLY = {'data'}
    
    def should_skip_dir(path: Path) -> bool:
        return path.name in EXCLUDE_DIRS
        
    def get_structure(path: Path, indent: str = "", is_root: bool = False) -> list[str]:
        lines = []
        
        if not is_root:
            # Add folder (skip for root level)
            lines.append(f"{indent}+-- {path.name}/")
        
        # Check if we're in a data folder (only show directories, no files)
        in_data_folder = any(parent.name in DATA_FOLDER_ONLY for parent in path.parents)
        
        # Process contents
        items = sorted(path.iterdir(), key=lambda x: (not x.is_dir(), x.name))
        next_indent = "" if is_root else indent + "|   "
        
        for item in items:
            if item.is_dir():
                if should_skip_dir(item):
                    continue
                    
                lines.extend(get_structure(item, next_indent))
            elif not in_data_folder and not is_root:  # Only include files if not in data folder and not root
                # Check if file is empty
                is_empty = item.stat().st_size == 0
                empty_marker = " [empty]" if is_empty else ""
                lines.append(f"{indent}|-- {item.name}{empty_marker}")
                
        return lines
    
    try:
        # Get structure starting from current directory, marking it as root
        structure = get_structure(Path.cwd(), is_root=True)
        
        # Write to file with UTF-8 encoding
        with open(output, 'w', encoding='utf-8') as f:
            f.write("\n".join(structure))
            
        click.echo(click.style("\nStructure written successfully", fg='green'))
        
    except Exception as e:
        click.echo(click.style(f"\nError generating structure: {e}", fg='red'))

@dev.command()
@click.option('--output-dir', default="combined_files", help='Output directory for combined files')
def combine(output_dir: str):
    """Combine non-empty files within each subfolder into single txt files"""
    click.echo(f"\nCombining files into directory: {output_dir}")
    
    EXCLUDE_DIRS = {
        '.git', '__pycache__', 'backend',
        'author_photos', 'book_covers', 'exported_html',
        'data', 'combined_files'  # Don't process data dir or our output dir
    }
    
    EXCLUDE_EXTENSIONS = {'.pyc', '.db', '.jpg', '.png', '.gif'}
    
    def should_skip_dir(path: Path) -> bool:
        return path.name in EXCLUDE_DIRS or path.name.startswith('.')
    
    def should_include_file(path: Path) -> bool:
        # Skip empty files and files with excluded extensions
        return (path.stat().st_size > 0 and 
                path.suffix.lower() not in EXCLUDE_EXTENSIONS and
                not path.name.startswith('.'))
    
    def process_directory(dir_path: Path, output_base: Path, is_root: bool = False):
        # Skip excluded directories
        if should_skip_dir(dir_path):
            return
            
        # Collect all non-empty files in this directory
        files_content = []
        for item in dir_path.iterdir():
            if item.is_file() and should_include_file(item):
                try:
                    content = item.read_text(encoding='utf-8')
                    # Get relative path from the root directory
                    rel_path = str(item.relative_to(Path.cwd())).replace('/', '\\')
                    
                    # Check if content already starts with a separator
                    header = f"# {rel_path}\n\n"
                    if not content.startswith("# "):
                        files_content.append(f"{header}{content}\n\n")
                    else:
                        files_content.append(f"{content}\n\n")
                except Exception as e:
                    click.echo(click.style(f"Error reading {item}: {e}", fg='yellow'))
        
        # If we found any files, combine them
        if files_content and not is_root:
            # Create simplified filename from directory path
            rel_dir = str(dir_path.relative_to(Path.cwd()))
            simplified_name = rel_dir.replace('\\', '-').replace('/', '-') + '.txt'
            
            output_file = output_base / simplified_name
            try:
                output_file.write_text("\n".join(files_content), encoding='utf-8')
                click.echo(f"Created combined file: {output_file}")
            except Exception as e:
                click.echo(click.style(f"Error writing {output_file}: {e}", fg='red'))
        
        # Process subdirectories
        for item in dir_path.iterdir():
            if item.is_dir():
                process_directory(item, output_base, False)
    
    try:
        # Create output directory
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        # Start processing from current directory
        process_directory(Path.cwd(), output_path, is_root=True)
        
        click.echo(click.style("\nFiles combined successfully", fg='green'))
        
    except Exception as e:
        click.echo(click.style(f"\nError combining files: {e}", fg='red'))


# cli\commands\genre.py

import click
from core.database import GoodreadsDB
from core.database.queries import BookQueries

@click.group()
def genre():
    """Genre management commands"""
    pass

@genre.command(name="list")
@click.option('--db-path', '--db', default="books.db", help="Path to the books database")
@click.argument('genre_name')
def list_books(db_path: str, genre_name: str):
    """
    List all books in a specific genre, including Goodreads votes,
    ordered by votes (highest first).

    GENRE_NAME is the name of the genre to filter books by.
    """
    db = GoodreadsDB(db_path)
    # Instantiate the BookQueries with our DB instance (which provides execute_query)
    queries = BookQueries(db)
    books = queries.get_books_by_genre(genre_name)
    
    if books:
        click.echo(f"\nBooks in genre '{genre_name}':")
        for book in books:
            votes = book.get('goodreads_votes')
            votes_str = f"{votes}" if votes is not None else "N/A"
            click.echo(f" - {book['title']} (Goodreads ID: {book['goodreads_id']}, Votes: {votes_str})")
    else:
        click.echo(f"\nNo books found in genre '{genre_name}'.")

if __name__ == '__main__':
    genre()



# core/cli/commands/library.py
import click
from core.database import GoodreadsDB

@click.group()
def library():
    """Library management commands"""
    pass

@library.command()
@click.option('--db-path', '--db', default="books.db", help='Path to books database')
@click.option('--calibre-path', default="C:/Users/warre/Calibre Library/metadata.db", required=True, help='Path to Calibre metadata.db')
@click.option('--limit', default=None, type=int, help='Limit number of books')
def import_calibre(db_path: str, calibre_path: str, limit: int):
    """Import books from Calibre library"""
    click.echo(f"\nImporting from Calibre: {calibre_path}")
    
    db = GoodreadsDB(db_path)
    total, imported = db.import_calibre_books(calibre_path, limit)
    
    click.echo(f"\nProcessed {total} books")
    click.echo(f"Successfully imported {imported} books")

@library.command()
@click.option('--db-path', '--db', default="books.db", help='Path to books database')
def stats(db_path: str):
    """Show library statistics"""
    db = GoodreadsDB(db_path)
    stats = db.get_stats()
    
    click.echo("\nLibrary Statistics:")
    for table, count in stats.items():
        click.echo(f"{table}: {count} records")

@library.command()
@click.argument('goodreads_id')
@click.option('--db-path', '--db', default="books.db", help='Path to books database')
@click.option('--force/--no-force', default=False, help='Skip confirmation prompt')
def delete(goodreads_id: str, db_path: str, force: bool):
    """Delete a book and its relationships from the database"""
    db = GoodreadsDB(db_path)
    
    # Get book details first
    book = db.get_by_id('book', goodreads_id, id_field='goodreads_id')
    if not book:
        click.echo(click.style(f"\nNo book found with ID: {goodreads_id}", fg='red'))
        return
        
    # Show confirmation unless force flag is used
    if not force:
        click.confirm(f"\nAre you sure you want to delete '{book['title']}'?", abort=True)
    
    if db.delete_book(goodreads_id):
        click.echo(click.style(f"\nSuccessfully deleted '{book['title']}'", fg='green'))
    else:
        click.echo(click.style("\nFailed to delete book", fg='red'))


# core/cli/commands/scraper.py
import click
import json
from pathlib import Path
from core.scrapers.book_scraper import BookScraper
from core.scrapers.author_scraper import AuthorScraper
from core.scrapers.author_books_scraper import AuthorBooksScraper
from core.scrapers.series_scraper import SeriesScraper
from core.scrapers.editions_scraper import EditionsScraper
from core.scrapers.similar_scraper import SimilarScraper

@click.group()
def scraper():
    """Commands for testing scrapers"""
    # Ensure data directories exist
    Path('data/cache/book/show').mkdir(parents=True, exist_ok=True)
    Path('data/cache/author/show').mkdir(parents=True, exist_ok=True)
    Path('data/cache/author/list').mkdir(parents=True, exist_ok=True)
    Path('data/cache/series/show').mkdir(parents=True, exist_ok=True)
    Path('data/cache/work/editions').mkdir(parents=True, exist_ok=True)
    Path('data/cache/book/similar').mkdir(parents=True, exist_ok=True)

@scraper.command()
@click.argument('book_id')
@click.option('--scrape/--no-scrape', default=False)
def book(book_id: str, scrape: bool):
    """Test book scraper output"""
    click.echo(f"\nTesting book scraper with ID: {book_id} (scrape={scrape})")
    
    scraper = BookScraper(scrape=scrape)  # Pass the scrape flag
    result = scraper.scrape_book(book_id)
    
    if result:
        click.echo(click.style("\nBook Data:", fg='green'))
        # Pretty print the result
        click.echo(json.dumps(result, indent=2))
    else:
        click.echo(click.style("\nFailed to get book data", fg='red'))

@scraper.command()
@click.argument('author_id')
@click.option('--scrape/--no-scrape', default=False)
def author(author_id: str, scrape: bool):
    """Test author scraper output"""
    click.echo(f"\nTesting author scraper with ID: {author_id} (scrape={scrape})")
    
    scraper = AuthorScraper(scrape=scrape)  # Pass the scrape flag
    result = scraper.scrape_author(author_id)
    
    if result:
        click.echo(click.style("\nAuthor Data:", fg='green'))
        # Pretty print the result
        click.echo(json.dumps(result, indent=2))
    else:
        click.echo(click.style("\nFailed to get author data", fg='red'))

@scraper.command()
@click.argument('author_id')
@click.option('--scrape/--no-scrape', default=False)
def author_books(author_id: str, scrape: bool):
    """Test author books scraper output"""
    click.echo(f"\nTesting author books scraper with ID: {author_id} (scrape={scrape})")
    
    scraper = AuthorBooksScraper(scrape=scrape)  # Pass the scrape flag
    result = scraper.scrape_author_books(author_id)
    
    if result:
        click.echo(click.style("\nAuthor Books Data:", fg='green'))
        # Pretty print the result
        click.echo(json.dumps(result, indent=2))
    else:
        click.echo(click.style("\nFailed to get author books data", fg='red'))

@scraper.command()
@click.argument('series_id')
@click.option('--scrape/--no-scrape', default=False)
def series(series_id: str, scrape: bool):
    """Test series scraper output"""
    click.echo(f"\nTesting series scraper with ID: {series_id} (scrape={scrape})")
    
    scraper = SeriesScraper(scrape=scrape)  # Pass the scrape flag
    result = scraper.scrape_series(series_id)
    
    if result:
        click.echo(click.style("\nSeries Data:", fg='green'))
        # Pretty print the result
        click.echo(json.dumps(result, indent=2))
    else:
        click.echo(click.style("\nFailed to get series data", fg='red'))

@scraper.command()
@click.argument('work_id')
@click.option('--scrape/--no-scrape', default=False)
def editions(work_id: str, scrape: bool):
    """Test editions scraper output"""
    click.echo(f"\nTesting editions scraper with ID: {work_id} (scrape={scrape})")
    
    scraper = EditionsScraper(scrape=scrape)  # Pass the scrape flag
    result = scraper.scrape_editions(work_id)
    
    if result:
        click.echo(click.style("\nEditions Data:", fg='green'))
        # Pretty print the result
        click.echo(json.dumps(result, indent=2))
    else:
        click.echo(click.style("\nFailed to get editions data", fg='red'))
        
@scraper.command()
@click.argument('book_id')
@click.option('--scrape/--no-scrape', default=False)
def similar(book_id: str, scrape: bool):
    """Test similar books scraper output"""
    click.echo(f"\nTesting similar books scraper with ID: {book_id} (scrape={scrape})")
    
    scraper = SimilarScraper(scrape=scrape)  # Pass the scrape flag
    result = scraper.scrape_similar_books(book_id)
    
    if result:
        click.echo(click.style("\nSimilar Books Data:", fg='green'))
        # Pretty print the result
        click.echo(json.dumps(result, indent=2))
    else:
        click.echo(click.style("\nFailed to get similar books data", fg='red'))


# cli\commands\series.py

import click
from core.database import GoodreadsDB

@click.group()
def series():
    """Series management commands"""
    pass

@series.command()
@click.option('--db-path', '--db', default="books.db", help='Path to books database')
@click.option('--days', default=30, help='Sync series not updated in this many days')
@click.option('--limit', default=None, type=int, help='Limit number of series to sync')
def sync(db_path: str, days: int, limit: int):
    """Sync unsynced series and import their books"""
    click.echo(f"\nSyncing series not updated in {days} days")
    if limit:
        click.echo(f"Limited to {limit} series")
    
    db = GoodreadsDB(db_path)
    processed, imported = db.sync_series(days, limit)
    
    click.echo(f"\nProcessed {processed} series")
    click.echo(f"Imported {imported} new books")



# cli/commands/similar.py

import click
from core.database import GoodreadsDB

@click.group()
def similar():
    """Similar books management commands"""
    pass

@similar.command()
@click.option('--db-path', '--db', default="books.db", help='Path to the books database')
@click.option('--source', default=None, help='Filter by source (e.g. "library")')
@click.option('--limit', default=None, type=int, help='Limit number of books to sync')
def sync(db_path: str, source: str, limit: int):
    """
    Sync similar books for books that do not have any similar-book entries.
    For each such book (optionally filtered by source), this command will scrape
    similar books and import the relationships into the database.
    """
    click.echo("\nSyncing similar books...")
    if source:
        click.echo(f"Filtering by source: {source}")
    if limit:
        click.echo(f"Limited to {limit} books")

    db = GoodreadsDB(db_path)
    processed, imported = db.sync_similar(source, limit)

    click.echo(f"\nProcessed {processed} books")
    click.echo(f"Imported {imported} similar relationships")

if __name__ == '__main__':
    similar()


