# core/sa/repositories/author.py
from typing import Optional, List
from datetime import datetime, timedelta, UTC
from sqlalchemy import desc, func, or_, distinct
from sqlalchemy.orm import Session
from ..models import Author, Book, BookAuthor, BookUser

class AuthorRepository:
    def __init__(self, session: Session):
        self.session = session

    def get_by_goodreads_id(self, goodreads_id: str) -> Optional[Author]:
        """Get an author by Goodreads ID"""
        return self.session.query(Author).filter(Author.goodreads_id == goodreads_id).first()

    def search_authors(self, query: str, limit: int = 20) -> List[Author]:
        """Search authors by name"""
        base_query = self.session.query(Author)
        if query:  # Only apply filter if query is not empty
            base_query = base_query.filter(Author.name.ilike(f"%{query}%"))
        return base_query.limit(limit).all()

    def get_recent_authors(self, limit: int = 10) -> List[Author]:
        """Get recently added authors"""
        return self.session.query(Author).order_by(
            desc(Author.created_at)
        ).limit(limit).all()

    def get_authors_by_book(self, book_id: str) -> List[Author]:
        """Get all authors for a specific book"""
        return self.session.query(Author).join(
            Author.books
        ).filter(
            Book.goodreads_id == book_id
        ).all()

    def get_unsynced_authors(self, days_old: int = 30, source: Optional[str] = None) -> List[Author]:
        """Get authors not synced within specified days, optionally filtered by book source
        
        Args:
            days_old: Number of days since last sync
            source: Optional source to filter by (e.g. 'library', 'series', 'read', 'top')
                   'read' will find authors of books that any user has read
                   'top' will find authors of highly voted books on Goodreads
            
        Returns:
            List of Author objects that need syncing
        """
        cutoff_date = datetime.now(UTC) - timedelta(days=days_old)
        query = self.session.query(Author).filter(
            (Author.last_synced_at.is_(None)) | 
            (Author.last_synced_at < cutoff_date)
        )
        
        # If source is specified, only include authors who have books from that source
        if source:
            if source == 'read':
                # Find authors of books that any user has read
                query = (
                    query
                    .join(BookAuthor)
                    .join(Book)
                    .join(BookUser)
                    .filter(BookUser.status == 'completed')
                    .distinct()
                )
            elif source == 'top':
                # Find authors of highly voted books
                # Join with books and get max votes per author
                query = (
                    query
                    .join(BookAuthor)
                    .join(Book)
                    .filter(
                        Book.goodreads_votes.isnot(None),
                        Book.published_date >= '2000-01-01',  # Only books published after 2000
                        Book.published_date.isnot(None)  # Ensure we have a publication date
                    )
                    .group_by(Author.goodreads_id)
                    .having(func.max(Book.goodreads_votes) >= 10000)  # Minimum vote threshold
                    .order_by(desc(func.max(Book.goodreads_votes)))
                )
            else:
                query = query.join(BookAuthor).join(Book).filter(Book.source == source)
            
        query = query.order_by(Author.last_synced_at.asc().nullsfirst())
        
        authors = query.all()
        return [author for author in authors if author is not None]

    def get_prolific_authors(self, min_books: int = 5) -> List[Author]:
        """Get authors with at least the specified number of books"""
        return self.session.query(Author).join(
            Author.books
        ).group_by(
            Author.goodreads_id
        ).having(
            func.count(Book.goodreads_id) >= min_books
        ).all()


# core/sa/repositories/book.py
from typing import Optional, List, Dict, Any
from datetime import datetime
from sqlalchemy import select, desc, not_, exists, func, case, and_, or_
from sqlalchemy.orm import Session, joinedload
from ..models import Book, Author, Genre, Series, BookSimilar, BookAuthor, BookSeries, BookUser

class BookRepository:
    def __init__(self, session: Session):
        self.session = session

    def get_by_goodreads_id(self, goodreads_id: str) -> Optional[Book]:
        """Get a book by its Goodreads ID"""
        return self.session.query(Book).filter(Book.goodreads_id == goodreads_id).first()

    def get_by_work_id(self, work_id: str) -> Optional[Book]:
        """Get a book by its work ID with all relationships loaded.
        
        Args:
            work_id: The work ID of the book
            
        Returns:
            Book object with loaded relationships (authors, series, genres, similar books, user status)
            or None if not found
        """
        return (
            self.session.query(Book)
            .filter(Book.work_id == work_id)
            .options(
                joinedload(Book.book_authors).joinedload(BookAuthor.author),
                joinedload(Book.book_series).joinedload(BookSeries.series),
                joinedload(Book.genres),
                joinedload(Book.book_users),
                joinedload(Book.similar_to).joinedload(BookSimilar.similar_book)
            )
            .first()
        )

    def search_books(
        self, 
        query: Optional[str] = None,
        source: Optional[str] = None,
        sort_field: str = "goodreads_votes",
        sort_order: str = "desc",
        limit: int = 20,
        offset: int = 0
    ) -> List[Book]:
        """Search books by title and include author relationships.
        
        Args:
            query: Search query string
            source: Filter by source
            sort_field: Field to sort by (goodreads_votes, goodreads_rating, title, published_date, created_at)
            sort_order: Sort order (asc or desc)
            limit: Maximum number of results to return
            offset: Number of records to skip
            
        Returns:
            List of Book objects with loaded author relationships
        """
        base_query = self.session.query(Book).options(
            joinedload(Book.book_authors).joinedload(BookAuthor.author),
            joinedload(Book.genres),
            joinedload(Book.series)
        )
        
        if query and query.strip():
            base_query = base_query.filter(Book.title.ilike(f"%{query}%"))
            
        if source:
            base_query = base_query.filter(Book.source == source)
        
        # Apply sorting
        valid_sort_fields = {
            "goodreads_votes": Book.goodreads_votes,
            "goodreads_rating": Book.goodreads_rating,
            "title": Book.title,
            "published_date": Book.published_date,
            "created_at": Book.created_at
        }
        
        sort_column = valid_sort_fields.get(sort_field, Book.goodreads_votes)
        if sort_order == "desc":
            base_query = base_query.order_by(desc(sort_column))
        else:
            base_query = base_query.order_by(sort_column)
        
        return base_query.offset(offset).limit(limit).all()
        
    def count_books(
        self,
        query: Optional[str] = None,
        source: Optional[str] = None
    ) -> int:
        """Count total books matching the search criteria.
        
        Args:
            query: Search query string
            source: Filter by source
            
        Returns:
            Total count of matching books
        """
        base_query = self.session.query(Book)
        
        if query and query.strip():
            base_query = base_query.filter(Book.title.ilike(f"%{query}%"))
            
        if source:
            base_query = base_query.filter(Book.source == source)
            
        return base_query.count()

    def get_books_by_author(
        self,
        author_id: str,
        user_id: Optional[int] = None,
        limit: int = 20,
        offset: int = 0
    ) -> List[Book]:
        """Get books by an author, sorted by publication date.
        
        Args:
            author_id: The Goodreads ID of the author
            user_id: Optional user ID to include read status and wanted status
            limit: Maximum number of books to return
            offset: Number of books to skip
            
        Returns:
            List of Book objects with loaded relationships
        """
        query = (
            self.session.query(Book)
            .join(BookAuthor)
            .filter(BookAuthor.author_id == author_id)
            .options(
                joinedload(Book.book_authors).joinedload(BookAuthor.author),
                joinedload(Book.book_series).joinedload(BookSeries.series)
            )
        )
        
        # Add user-specific relationships if user_id provided
        if user_id is not None:
            query = query.options(
                joinedload(Book.book_users),
                joinedload(Book.book_wanted)
            )
            
        # Sort by publication date (nulls last)
        query = query.order_by(
            Book.published_date.asc().nulls_last(),
            Book.title.asc()
        )
        
        return query.offset(offset).limit(limit).all()

    def count_books_by_author(self, author_id: str) -> int:
        """Count total books by an author.
        
        Args:
            author_id: The Goodreads ID of the author
            
        Returns:
            Total count of books by the author
        """
        return (
            self.session.query(func.count(Book.work_id))
            .join(BookAuthor)
            .filter(BookAuthor.author_id == author_id)
            .scalar() or 0
        )

    def get_books_by_genre(self, genre_name: str) -> List[Book]:
        """Get all books in a specific genre"""
        return self.session.query(Book).join(
            Book.genres
        ).filter(
            Genre.name == genre_name
        ).all()

    def get_books_with_rating_above(self, rating: float) -> List[Book]:
        """Get books with rating above specified threshold"""
        return self.session.query(Book).filter(
            Book.goodreads_rating >= rating
        ).order_by(
            desc(Book.goodreads_rating)
        ).all()

    def get_recent_books(self, limit: int = 10) -> List[Book]:
        """Get recently added books"""
        return self.session.query(Book).order_by(
            desc(Book.created_at)
        ).limit(limit).all()

    def get_books_in_series(self, series_id: str) -> List[Book]:
        """Get all books in a specific series"""
        return self.session.query(Book).join(
            Book.series
        ).filter(
            Series.goodreads_id == series_id
        ).all()

    def get_similar_books(self, work_id: str, limit: int = 10) -> List[Book]:
        """Get similar books for a given book"""
        book = self.session.query(Book).filter(Book.work_id == work_id).first()
        if not book:
            return []
        return book.similar_books[:limit]

    def get_books_with_filters(
        self,
        min_rating: Optional[float] = None,
        min_votes: Optional[int] = None,
        language: Optional[str] = None,
        limit: int = 50
    ) -> List[Book]:
        """Get books matching multiple filter criteria"""
        query = self.session.query(Book)
        
        if min_rating is not None:
            query = query.filter(Book.goodreads_rating >= min_rating)
        if min_votes is not None:
            query = query.filter(Book.goodreads_votes >= min_votes)
        if language is not None:
            query = query.filter(Book.language == language)
            
        return query.limit(limit).all()

    def get_books_without_similar(self, source: Optional[str] = None) -> List[Book]:
        """Get books that don't have any similar books synced yet.
        
        Args:
            source: Optional source filter:
                   - 'library' for library books
                   - 'read' for books that any user has read
                   - any other source value will filter by that source
            
        Returns:
            List of Book objects that haven't been synced for similar books
        """
        # Start with base query
        query = self.session.query(Book)
        
        # Add source filter if specified
        if source:
            if source == 'read':
                # Find books that any user has read
                query = (
                    query
                    .join(BookUser)
                    .filter(BookUser.status == 'completed')
                    .distinct()
                )
            else:
                query = query.filter(Book.source == source)
        
        # Filter for books that haven't been synced for similar books
        query = query.filter(Book.similar_synced_at.is_(None))
        
        # Order by rating desc so we process popular books first
        return query.order_by(desc(Book.goodreads_rating)).all()

    def get_series_with_counts(
        self,
        query: Optional[str] = None,
        user_id: Optional[int] = None,
        sort_by: str = "book_count",
        limit: int = 20,
        offset: int = 0
    ) -> List[tuple[Series, int, int]]:
        """Get series with their book counts and user read counts.
        
        Args:
            query: Optional search string to filter series by title
            user_id: Optional user ID to get read counts for
            sort_by: Sort by 'book_count' or 'read_count'
            limit: Maximum number of results to return
            offset: Number of records to skip
            
        Returns:
            List of tuples containing (Series, total_book_count, user_read_count)
        """
        # Subquery to count completed books for the user in each series
        if user_id is not None:
            user_read_count = (
                func.count(
                    func.distinct(
                        case(
                            (and_(
                                BookUser.user_id == user_id,
                                BookUser.status == "completed"
                            ), Book.work_id),
                            else_=None
                        )
                    )
                ).label('user_read_count')
            )
        else:
            # For SQLite, use a simpler expression that always returns 0
            user_read_count = func.count(None).label('user_read_count')
            user_read_count = (user_read_count - user_read_count).label('user_read_count')

        base_query = (
            self.session.query(
                Series,
                func.count(func.distinct(Book.work_id)).label('book_count'),
                user_read_count
            )
            .select_from(Series)
            .join(BookSeries, Series.goodreads_id == BookSeries.series_id)
            .join(Book, Book.work_id == BookSeries.work_id)
        )
        
        if user_id is not None:
            base_query = base_query.outerjoin(
                BookUser,
                and_(
                    BookUser.work_id == Book.work_id,
                    BookUser.user_id == user_id,
                    BookUser.status == "completed"
                )
            )
        
        base_query = base_query.group_by(Series)
        
        if query and query.strip():
            base_query = base_query.filter(Series.title.ilike(f"%{query}%"))
            
        # Apply sorting
        if sort_by == "read_count":
            base_query = base_query.order_by(desc('user_read_count'), desc('book_count'), Series.title)
        else:  # Default to book_count
            base_query = base_query.order_by(desc('book_count'), Series.title)
            
        return base_query.offset(offset).limit(limit).all()
        
    def count_series(self, query: Optional[str] = None) -> int:
        """Count total number of series.
        
        Args:
            query: Optional search string to filter series by title
            
        Returns:
            Total count of series matching the criteria
        """
        base_query = self.session.query(Series)
        
        if query and query.strip():
            base_query = base_query.filter(Series.title.ilike(f"%{query}%"))
            
        return base_query.count()

    def get_all_books_with_images(self, force: bool = False) -> List[Book]:
        """Get books that need image conversion.
        
        Args:
            force: If True, get all books with images regardless of format.
                  If False, only get books with non-WebP images.
        
        Returns:
            List of Book objects that need image processing
        """
        query = self.session.query(Book).filter(Book.image_url.isnot(None))
        
        if not force:
            # Only get books that don't already have WebP images
            query = query.filter(not_(Book.image_url.like('%.webp')))
            
        return query.all()

    def update_book_status(
        self,
        user_id: int,
        work_id: str,
        status: Optional[str],
        source: Optional[str] = None,
        started_at: Optional[datetime] = None,
        finished_at: Optional[datetime] = None,
        update_none: bool = False
    ) -> Optional[BookUser]:
        """Update or create a book status for a user.
        
        Args:
            user_id: ID of the user
            work_id: Work ID of the book
            status: Reading status (reading, completed)
            source: Optional source of the book
            started_at: Optional start date
            finished_at: Optional finish date
            update_none: If True, None values will be applied (used to explicitly set nulls)
            
        Returns:
            Updated or created BookUser object, or None if book not found
        """
        # Get the book first
        book = self.get_by_work_id(work_id)
        if not book:
            return None
            
        # Check if status already exists
        book_user = (
            self.session.query(BookUser)
            .filter(
                BookUser.user_id == user_id,
                BookUser.work_id == work_id
            )
            .first()
        )
        
        if book_user:
            # Update existing status
            if status is not None or update_none:
                book_user.status = status
            if source is not None or update_none:
                book_user.source = source
            if started_at is not None or update_none:
                book_user.started_at = started_at
            if finished_at is not None or update_none:
                book_user.finished_at = finished_at
        else:
            # Create new status
            book_user = BookUser(
                user_id=user_id,
                work_id=work_id,
                status=status,
                source=source,
                started_at=started_at,
                finished_at=finished_at
            )
            self.session.add(book_user)
            
        try:
            self.session.commit()
            return book_user
        except:
            self.session.rollback()
            raise

    def delete_book_status(self, user_id: int, work_id: str) -> bool:
        """Delete a book status for a user.
        
        Args:
            user_id: The ID of the user
            work_id: The work ID of the book
            
        Returns:
            True if the status was deleted, False if not found
        """
        result = (
            self.session.query(BookUser)
            .filter(
                BookUser.user_id == user_id,
                BookUser.work_id == work_id
            )
            .delete()
        )
        self.session.commit()
        return result > 0


# core/sa/repositories/genre.py

from typing import List, Optional
from sqlalchemy import func, desc
from sqlalchemy.orm import Session, joinedload
from core.sa.models import Genre, Book, BookGenre

class GenreRepository:
    """Repository for managing Genre entities."""

    def __init__(self, session: Session):
        """Initialize the repository with a database session.
        
        Args:
            session: SQLAlchemy session for database operations
        """
        self.session = session

    def get_by_name(self, name: str) -> Optional[Genre]:
        """Get a genre by its name.
        
        Args:
            name: The name of the genre to retrieve
            
        Returns:
            The Genre object if found, None otherwise
        """
        return self.session.query(Genre).filter(Genre.name == name).first()

    def search_genres(self, query: str, limit: int = 20) -> List[Genre]:
        """Search for genres by name.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 20)
            
        Returns:
            List of matching Genre objects
        """
        base_query = self.session.query(Genre)
        if query:
            base_query = base_query.filter(Genre.name.ilike(f"%{query}%"))
        return base_query.limit(limit).all()

    def get_genres_by_book(self, goodreads_id: str) -> List[Genre]:
        """Get all genres associated with a specific book.
        
        Args:
            goodreads_id: The Goodreads ID of the book
            
        Returns:
            List of Genre objects associated with the book
        """
        book = self.session.query(Book).filter(Book.goodreads_id == goodreads_id).first()
        if not book:
            return []
        return (
            self.session.query(Genre)
            .join(Genre.book_genres)
            .join(BookGenre.book)
            .filter(Book.goodreads_id == goodreads_id)
            .all()
        )

    def get_popular_genres(self, limit: int = 10) -> List[Genre]:
        """Get genres ordered by number of associated books.
        
        Args:
            limit: Maximum number of genres to return (default: 10)
            
        Returns:
            List of Genre objects ordered by popularity
        """
        return (self.session.query(Genre)
                .outerjoin(Genre.book_genres)
                .group_by(Genre)
                .order_by(desc(func.count(BookGenre.work_id)))
                .options(joinedload(Genre.book_genres).joinedload(BookGenre.book))
                .limit(limit)
                .all())

    def get_recent_genres(self, limit: int = 10) -> List[Genre]:
        """Get recently added genres.
        
        Args:
            limit: Maximum number of genres to return (default: 10)
            
        Returns:
            List of Genre objects ordered by creation date
        """
        return (self.session.query(Genre)
                .order_by(desc(Genre.created_at))
                .limit(limit)
                .all())

    def merge_genres(self, source_name: str, target_name: str) -> Optional[Genre]:
        """Merge one genre into another.
        
        Args:
            source_name: Name of the genre to merge from
            target_name: Name of the genre to merge into
            
        Returns:
            The target Genre object if successful, None otherwise
        """
        source = self.get_by_name(source_name)
        target = self.get_by_name(target_name)

        if not source or not target:
            return None

        # Get all books associated with the source genre
        source_books = (
            self.session.query(Book)
            .join(Book.book_genres)
            .filter(BookGenre.genre_id == source.id)
            .all()
        )

        # Delete all book-genre associations for the source genre
        self.session.query(BookGenre).filter(BookGenre.genre_id == source.id).delete()

        # Create new book-genre associations with the target genre
        for book in source_books:
            # Check if this book is already associated with the target genre
            existing = (
                self.session.query(BookGenre)
                .filter(
                    BookGenre.work_id == book.work_id,
                    BookGenre.genre_id == target.id
                )
                .first()
            )
            if not existing:
                # Create new association with target genre
                new_book_genre = BookGenre(
                    work_id=book.work_id,
                    genre_id=target.id
                )
                self.session.add(new_book_genre)

        # Delete the source genre
        self.session.delete(source)
        self.session.commit()

        return target 


# core\sa\repositories\library.py

from typing import List, Optional
from sqlalchemy import func, desc
from sqlalchemy.orm import Session, joinedload
from core.sa.models import Library, Book

class LibraryRepository:
    """Repository for managing Library entities."""

    def __init__(self, session: Session):
        """Initialize the repository with a database session.
        
        Args:
            session: SQLAlchemy session for database operations
        """
        self.session = session

    def get_by_id(self, library_id: int) -> Optional[Library]:
        """Get a library entry by its ID.
        
        Args:
            library_id: The ID of the library entry to retrieve
            
        Returns:
            The Library object if found, None otherwise
        """
        return self.session.query(Library).filter(Library.id == library_id).first()

    def get_by_calibre_id(self, calibre_id: int) -> Optional[Library]:
        """Get a library entry by its Calibre ID.
        
        Args:
            calibre_id: The Calibre ID to search for
            
        Returns:
            The Library object if found, None otherwise
        """
        return self.session.query(Library).filter(Library.calibre_id == calibre_id).first()

    def get_by_goodreads_id(self, goodreads_id: str) -> Optional[Library]:
        """Get a library entry by its Goodreads ID.
        
        Args:
            goodreads_id: The Goodreads ID to search for
            
        Returns:
            The Library object if found, None otherwise
        """
        return self.session.query(Library).filter(Library.goodreads_id == goodreads_id).first()

    def get_by_isbn(self, isbn: str) -> List[Library]:
        """Get library entries by ISBN.
        
        Args:
            isbn: The ISBN to search for
            
        Returns:
            List of Library objects with matching ISBN
        """
        return self.session.query(Library).filter(Library.isbn == isbn).all()

    def search_by_title(self, query: str, limit: int = 20) -> List[Library]:
        """Search for library entries by title.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 20)
            
        Returns:
            List of matching Library objects
        """
        return (
            self.session.query(Library)
            .filter(Library.title.ilike(f"%{query}%"))
            .limit(limit)
            .all()
        )

    def get_library_with_book(self, library_id: int) -> Optional[Library]:
        """Get a library entry with its associated book relationship.
        
        Args:
            library_id: The ID of the library entry
            
        Returns:
            The Library object with loaded book relationship if found, None otherwise
        """
        return (
            self.session.query(Library)
            .options(joinedload(Library.book))
            .filter(Library.id == library_id)
            .first()
        )

    def get_all_by_work_id(self, work_id: str) -> List[Library]:
        """Get all library entries for a specific work ID.
        
        Args:
            work_id: The work ID to search for
            
        Returns:
            List of Library objects with matching work ID
        """
        return self.session.query(Library).filter(Library.work_id == work_id).all()

    def create_entry(
        self,
        title: str,
        work_id: str,
        calibre_id: Optional[int] = None,
        goodreads_id: Optional[str] = None,
        isbn: Optional[str] = None
    ) -> Library:
        """Create a new library entry.
        
        Args:
            title: The title of the book
            work_id: The work ID of the book
            calibre_id: Optional Calibre ID
            goodreads_id: Optional Goodreads ID
            isbn: Optional ISBN
            
        Returns:
            The created Library object
        """
        library = Library(
            title=title,
            work_id=work_id,
            calibre_id=calibre_id,
            goodreads_id=goodreads_id,
            isbn=isbn
        )
        self.session.add(library)
        self.session.commit()
        return library

    def update_entry(
        self,
        library_id: int,
        title: Optional[str] = None,
        calibre_id: Optional[int] = None,
        goodreads_id: Optional[str] = None,
        isbn: Optional[str] = None
    ) -> Optional[Library]:
        """Update an existing library entry.
        
        Args:
            library_id: The ID of the library entry to update
            title: Optional new title
            calibre_id: Optional new Calibre ID
            goodreads_id: Optional new Goodreads ID
            isbn: Optional new ISBN
            
        Returns:
            The updated Library object if found, None otherwise
        """
        library = self.get_by_id(library_id)
        if not library:
            return None

        if title is not None:
            library.title = title
        if calibre_id is not None:
            library.calibre_id = calibre_id
        if goodreads_id is not None:
            library.goodreads_id = goodreads_id
        if isbn is not None:
            library.isbn = isbn

        self.session.commit()
        return library

    def delete_entry(self, library_id: int) -> bool:
        """Delete a library entry.
        
        Args:
            library_id: The ID of the library entry to delete
            
        Returns:
            True if the entry was deleted, False if not found
        """
        library = self.get_by_id(library_id)
        if not library:
            return False

        self.session.delete(library)
        self.session.commit()
        return True 


# core/sa/repositories/series.py

from typing import Optional, List
from sqlalchemy.orm import Session, joinedload
from core.sa.models import Series, Book, BookSeries
from datetime import datetime, timedelta, UTC
from sqlalchemy import or_

class SeriesRepository:
    def __init__(self, session: Session):
        self.session = session

    def get_by_goodreads_id(self, goodreads_id: str) -> Optional[Series]:
        """
        Fetch a series by its Goodreads ID.
        """
        return self.session.query(Series).filter(Series.goodreads_id == goodreads_id).first()

    def search_series(self, query: str, limit: int = 20) -> List[Series]:
        """
        Search for series whose titles match the given query (case-insensitive).
        """
        return (
            self.session.query(Series)
            .filter(Series.title.ilike(f"%{query}%"))
            .limit(limit)
            .all()
        )

    def get_series_with_books(self, goodreads_id: str) -> Optional[Series]:
        """
        Retrieve a series by its Goodreads ID along with its associated books.
        This uses joined loading to minimize additional database queries.
        """
        return (
            self.session.query(Series)
            .options(
                joinedload(Series.book_series).joinedload(BookSeries.book)
            )
            .filter(Series.goodreads_id == goodreads_id)
            .first()
        )

    def get_series_by_book(self, book_id: str) -> List[Series]:
        """
        Get all series that include a specific book.
        """
        return (
            self.session.query(Series)
            .join(Series.book_series)
            .join(BookSeries.book)
            .filter(Book.goodreads_id == book_id)
            .all()
        )

    def get_recent_series(self, limit: int = 10) -> List[Series]:
        """
        Get the most recently added series, ordered by the created_at timestamp.
        """
        return (
            self.session.query(Series)
            .order_by(Series.created_at.desc())
            .limit(limit)
            .all()
        )

    def get_series_needing_sync(self, days: int, limit: Optional[int] = None, source: Optional[str] = None) -> List[Series]:
        """
        Get series that haven't been synced in the specified number of days.
        Optionally filter by source of the books in the series.
        
        Args:
            days: Number of days since last sync
            limit: Maximum number of series to return
            source: Only include series with books from this source
            
        Returns:
            List of Series objects that need updating
        """
        cutoff_date = datetime.now(UTC) - timedelta(days=days)
        query = self.session.query(Series).filter(
            or_(
                Series.last_synced_at.is_(None),
                Series.last_synced_at < cutoff_date
            )
        )
        
        # If source is specified, only include series that have books from that source
        if source:
            query = query.join(Series.book_series).join(BookSeries.book).filter(Book.source == source)
            
        # Order by last sync date, nulls first
        query = query.order_by(Series.last_synced_at.asc().nullsfirst())
            
        if limit:
            query = query.limit(limit)
            
        return query.all()



# core\sa\repositories\user.py

from typing import List, Optional
from datetime import datetime, timedelta, UTC
from sqlalchemy import func, desc, and_, or_, case
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError
from core.sa.models import User, Book, BookUser, Library, BookAuthor, BookSeries, BookSimilar, Series, BookWanted, UserAuthorSubscription, UserSeriesSubscription, Author, Series, BookGenre, Genre

class UserRepository:
    """Repository for managing User entities."""

    def __init__(self, session: Session):
        """Initialize the repository with a database session.
        
        Args:
            session: SQLAlchemy session for database operations
        """
        self.session = session

    def create_user(self, name: str) -> User:
        """Create a new user.
        
        Args:
            name: The name of the user
            
        Returns:
            The created User object
            
        Raises:
            ValueError: If a user with the given name already exists
        """
        # Check if user already exists
        existing = self.session.query(User).filter(User.name == name).first()
        if existing:
            raise ValueError(f"User with name '{name}' already exists")

        user = User(name=name)
        self.session.add(user)
        try:
            self.session.commit()
            return user
        except IntegrityError:
            self.session.rollback()
            raise ValueError(f"User with name '{name}' already exists")

    def update_user(self, user_id: int, name: str) -> Optional[User]:
        """Update a user's details.
        
        Args:
            user_id: The ID of the user to update
            name: The new name for the user
            
        Returns:
            The updated User object if found, None otherwise
        """
        user = self.get_by_id(user_id)
        if not user:
            return None
            
        user.name = name
        self.session.commit()
        return user

    def delete_book_status(self, user_id: int, work_id: str) -> bool:
        """Delete a book status for a user.
        
        Args:
            user_id: The ID of the user
            work_id: The work ID of the book
            
        Returns:
            True if the status was deleted, False if not found
        """
        result = (
            self.session.query(BookUser)
            .filter(
                BookUser.user_id == user_id,
                BookUser.work_id == work_id
            )
            .delete()
        )
        self.session.commit()
        return result > 0

    def get_user_stats(self, user_id: int) -> dict:
        """Get reading statistics for a user.
        
        Args:
            user_id: The ID of the user
            
        Returns:
            Dictionary containing various reading statistics
        """
        user = self.get_user_with_books(user_id)
        if not user:
            return None

        # Get current year
        current_year = datetime.now(UTC).year
        
        # Calculate statistics
        total_books = len(user.book_users)
        books_read_this_year = sum(
            1 for bu in user.book_users 
            if bu.status == "completed" and bu.finished_at 
            and bu.finished_at.year == current_year
        )
        currently_reading = sum(1 for bu in user.book_users if bu.status == "reading")
        want_to_read = sum(1 for bu in user.book_users if bu.status == "want_to_read")
        
        # Calculate average rating if available
        completed_books = [bu.book for bu in user.book_users if bu.status == "completed"]
        ratings = [b.goodreads_rating for b in completed_books if b.goodreads_rating is not None]
        average_rating = sum(ratings) / len(ratings) if ratings else None
        
        # Calculate favorite genres
        genre_counts = {}
        for bu in user.book_users:
            for genre in bu.book.genres:
                genre_counts[genre.name] = genre_counts.get(genre.name, 0) + 1
        favorite_genres = sorted(genre_counts.keys(), key=lambda x: genre_counts[x], reverse=True)[:5]
        
        # Calculate reading pace (books per month)
        completed_statuses = [
            bu for bu in user.book_users 
            if bu.status == "completed" and bu.started_at and bu.finished_at
        ]
        if completed_statuses:
            total_reading_days = sum(
                (bu.finished_at - bu.started_at).days
                for bu in completed_statuses
            )
            reading_pace = (len(completed_statuses) * 30) / total_reading_days if total_reading_days > 0 else None
        else:
            reading_pace = None
        
        # Calculate total pages read
        total_pages = sum(
            bu.book.pages or 0
            for bu in user.book_users
            if bu.status == "completed" and bu.book.pages
        )
        
        return {
            "total_books": total_books,
            "books_read_this_year": books_read_this_year,
            "currently_reading": currently_reading,
            "want_to_read": want_to_read,
            "average_rating": average_rating,
            "favorite_genres": favorite_genres,
            "reading_pace": reading_pace,
            "total_pages_read": total_pages or None
        }

    def get_by_id(self, user_id: int) -> Optional[User]:
        """Get a user by their ID.
        
        Args:
            user_id: The ID of the user to retrieve
            
        Returns:
            The User object if found, None otherwise
        """
        return self.session.query(User).filter(User.id == user_id).one_or_none()

    def search_users(self, query: str, limit: int = 20) -> List[User]:
        """Search for users by name.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 20)
            
        Returns:
            List of matching User objects
        """
        base_query = self.session.query(User)
        if query:
            base_query = base_query.filter(User.name.ilike(f"%{query}%"))
        return base_query.limit(limit).all()

    def get_users_by_book(self, goodreads_id: str) -> List[User]:
        """Get all users who have a relationship with a specific book.
        
        Args:
            goodreads_id: The Goodreads ID of the book
            
        Returns:
            List of User objects associated with the book
        """
        return (
            self.session.query(User)
            .join(User.book_users)
            .join(BookUser.book)
            .filter(Book.goodreads_id == goodreads_id)
            .all()
        )

    def get_users_by_book_status(self, status: str, limit: int = 20) -> List[User]:
        """Get users who have books with a specific status.
        
        Args:
            status: The book status to filter by (e.g., 'reading', 'completed')
            limit: Maximum number of users to return (default: 20)
            
        Returns:
            List of User objects with books in the specified status
        """
        return (
            self.session.query(User)
            .join(User.book_users)
            .filter(BookUser.status == status)
            .group_by(User)
            .limit(limit)
            .all()
        )

    def get_active_readers(self, days: int = 30, limit: int = 20) -> List[User]:
        """Get users who have recently updated their book statuses.
        
        Args:
            days: Number of days to look back (default: 30)
            limit: Maximum number of users to return (default: 20)
            
        Returns:
            List of User objects ordered by recent activity
        """
        cutoff_date = datetime.now(UTC) - timedelta(days=days)
        return (
            self.session.query(User)
            .join(User.book_users)
            .filter(BookUser.updated_at >= cutoff_date)
            .group_by(User)
            .order_by(desc(func.max(BookUser.updated_at)))
            .limit(limit)
            .all()
        )

    def get_user_with_books(self, user_id: int) -> Optional[User]:
        """Get a user along with their book relationships.
        
        Args:
            user_id: The ID of the user to retrieve
            
        Returns:
            The User object with loaded book relationships if found, None otherwise
        """
        return (
            self.session.query(User)
            .options(
                joinedload(User.book_users)
                .joinedload(BookUser.book)
                .joinedload(Book.genres)
            )
            .filter(User.id == user_id)
            .first()
        )

    def update_book_status(
        self, 
        user_id: int, 
        goodreads_id: str, 
        status: str,
        source: Optional[str] = None,
        started_at: Optional[datetime] = None,
        finished_at: Optional[datetime] = None
    ) -> Optional[BookUser]:
        """Update or create a user's status for a book.
        
        Args:
            user_id: The ID of the user
            goodreads_id: The Goodreads ID of the book
            status: The new status to set
            source: Optional source of the status update
            started_at: Optional start date
            finished_at: Optional finish date
            
        Returns:
            The updated or created BookUser object if successful, None otherwise
        """
        # Get the book's work_id from the library table
        print(f"Looking for book with Goodreads ID: {goodreads_id}")
        library_entry = (
            self.session.query(Library)
            .filter(Library.goodreads_id == goodreads_id)
            .first()
        )
        if not library_entry:
            print(f"Library entry not found with Goodreads ID: {goodreads_id}")
            return None

        print(f"Found library entry: {library_entry.title} (work_id: {library_entry.work_id})")

        # Find existing book-user relationship or create new one
        book_user = (
            self.session.query(BookUser)
            .filter(
                BookUser.user_id == user_id,
                BookUser.work_id == library_entry.work_id
            )
            .first()
        )

        if book_user:
            print(f"Updating existing book status for user {user_id}")
            # Update existing relationship
            book_user.status = status
            book_user.source = source
            book_user.started_at = started_at
            book_user.finished_at = finished_at
        else:
            print(f"Creating new book status for user {user_id}")
            # Create new relationship
            book_user = BookUser(
                user_id=user_id,
                work_id=library_entry.work_id,
                status=status,
                source=source,
                started_at=started_at,
                finished_at=finished_at
            )
            self.session.add(book_user)

        try:
            self.session.commit()
            print("Successfully committed changes")
            return book_user
        except Exception as e:
            print(f"Error committing changes: {str(e)}")
            self.session.rollback()
            return None

    def get_or_create_user(self, name: str) -> User:
        """Get an existing user by name or create a new one.
        
        Args:
            name: The name of the user
            
        Returns:
            The existing or newly created User object
        """
        user = self.session.query(User).filter(User.name == name).first()
        if not user:
            user = User(name=name)
            self.session.add(user)
            self.session.commit()
        return user

    def get_user_books_by_statuses(
        self,
        user_id: int,
        statuses: List[str],
        limit: int = 20,
        offset: int = 0
    ) -> List[Book]:
        """Get books for a user with specific statuses.
        
        Args:
            user_id: The ID of the user
            statuses: List of book statuses to filter by (e.g., ['completed', 'reading'])
            limit: Maximum number of results to return
            offset: Number of records to skip
            
        Returns:
            List of Book objects with loaded relationships, ordered by finished_at date (NULL dates last)
        """
        return (
            self.session.query(Book)
            .join(BookUser, and_(
                BookUser.work_id == Book.work_id,
                BookUser.user_id == user_id,
                BookUser.status.in_(statuses)
            ))
            .options(
                joinedload(Book.book_authors).joinedload(BookAuthor.author),
                joinedload(Book.book_series).joinedload(BookSeries.series),
                joinedload(Book.book_users).joinedload(BookUser.book)
            )
            .order_by(
                case(
                    (BookUser.finished_at.is_(None), 1),
                    else_=0
                ),
                desc(BookUser.finished_at)
            )
            .offset(offset)
            .limit(limit)
            .all()
        )

    def count_user_books_by_statuses(
        self,
        user_id: int,
        statuses: List[str]
    ) -> int:
        """Count books for a user with specific statuses.
        
        Args:
            user_id: The ID of the user
            statuses: List of book statuses to filter by (e.g., ['completed', 'reading'])
            
        Returns:
            Total count of matching books
        """
        return (
            self.session.query(Book)
            .join(BookUser, and_(
                BookUser.work_id == Book.work_id,
                BookUser.user_id == user_id,
                BookUser.status.in_(statuses)
            ))
            .count()
        )

    def get_similar_books_for_user_reads(
        self,
        user_id: int,
        min_count: int = 1,
        limit: int = 20,
        offset: int = 0
    ) -> List[tuple[Book, int]]:
        """Get books that are marked as similar to the user's read books.
        
        Args:
            user_id: The ID of the user
            min_count: Minimum number of times a book should appear as similar
            limit: Maximum number of results to return
            offset: Number of records to skip
            
        Returns:
            List of tuples containing (Book, count) where count is the number of times
            the book appears as similar to the user's read books
        """
        # First get all the books the user has read
        read_books = (
            self.session.query(Book.work_id)
            .join(BookUser)
            .filter(
                BookUser.user_id == user_id,
                BookUser.status == "completed"
            )
        )
        
        # Then get similar books for those read books with their counts
        similar_books = (
            self.session.query(Book, func.count(Book.work_id).label('similar_count'))
            .join(BookSimilar, BookSimilar.similar_work_id == Book.work_id)
            .filter(BookSimilar.work_id.in_(read_books))
            .options(
                joinedload(Book.book_authors).joinedload(BookAuthor.author),
                joinedload(Book.book_series).joinedload(BookSeries.series)
            )
            .group_by(Book)
            .having(func.count(Book.work_id) >= min_count)
            .order_by(desc('similar_count'))
            .offset(offset)
            .limit(limit)
            .all()
        )
        
        return similar_books

    def count_similar_books_for_user_reads(
        self,
        user_id: int,
        min_count: int = 1
    ) -> int:
        """Count books that are marked as similar to the user's read books.
        
        Args:
            user_id: The ID of the user
            min_count: Minimum number of times a book should appear as similar
            
        Returns:
            Total count of similar books meeting the minimum count criteria
        """
        # First get all the books the user has read
        read_books = (
            self.session.query(Book.work_id)
            .join(BookUser)
            .filter(
                BookUser.user_id == user_id,
                BookUser.status == "completed"
            )
        )
        
        # Then count similar books meeting the minimum count criteria
        return (
            self.session.query(func.count(func.distinct(Book.work_id)))
            .select_from(Book)
            .join(BookSimilar, BookSimilar.similar_work_id == Book.work_id)
            .filter(BookSimilar.work_id.in_(read_books))
            .group_by(Book.work_id)
            .having(func.count(Book.work_id) >= min_count)
            .count()
        )

    def get_user_read_genre_counts(self, user_id: int) -> List[tuple[str, int, List[Book]]]:
        """Get counts of genres from books the user has read, along with top unread books per genre.
        
        Args:
            user_id: The ID of the user
            
        Returns:
            List of tuples containing (genre_name, count, top_unread_books) ordered by count descending
        """
        # Get all completed books for the user with their genres
        read_books = (
            self.session.query(Book)
            .join(BookUser)
            .filter(
                BookUser.user_id == user_id,
                BookUser.status == "completed"
            )
            .options(joinedload(Book.genres))
            .all()
        )
        print(f"Found {len(read_books)} read books for user {user_id}")
        
        # Get work_ids of all books the user has any status for (to exclude from unread)
        user_book_work_ids = set(
            book.work_id for book in
            self.session.query(Book)
            .join(BookUser)
            .filter(BookUser.user_id == user_id)
            .all()
        )
        print(f"User has {len(user_book_work_ids)} total books with any status")
        
        # Count genres and track books per genre
        genre_map = {}  # name -> count
        genre_books = {}  # name -> set of read book work_ids
        
        for book in read_books:
            for genre in book.genres:
                genre_map[genre.name] = genre_map.get(genre.name, 0) + 1
                if genre.name not in genre_books:
                    genre_books[genre.name] = set()
                genre_books[genre.name].add(book.work_id)
        
        print(f"Found {len(genre_map)} unique genres")
        
        # For each genre, get top 3 unread books by votes
        result = []
        for genre_name, count in sorted(genre_map.items(), key=lambda x: (-x[1], x[0])):
            print(f"\nProcessing genre: {genre_name} (count: {count})")
            
            # Get top 3 unread books for this genre
            top_unread = (
                self.session.query(Book)
                .join(Book.genres)
                .filter(
                    Book.genres.any(name=genre_name),
                    ~Book.work_id.in_(user_book_work_ids)
                )
                .options(
                    joinedload(Book.book_authors).joinedload(BookAuthor.author),
                    joinedload(Book.book_series).joinedload(BookSeries.series)
                )
                .order_by(
                    desc(Book.goodreads_votes),
                    desc(Book.goodreads_rating)
                )
                .distinct()  # Ensure we don't get duplicates
                .limit(10)  # Get top 10 books
                .all()
            )
            print(f"Found {len(top_unread)} unread books for genre {genre_name}")
            for book in top_unread:
                print(f"  - {book.title} (votes: {book.goodreads_votes})")
            
            result.append((genre_name, count, top_unread))
        
        return result

    def get_recommended_books(
        self,
        user_id: int,
        days: Optional[int] = None,
        limit: int = 20,
        offset: int = 0
    ) -> List[tuple[Book, int, List[tuple[str, int]]]]:
        """
        Get recommended books for a user based on their reading history.
        Books are scored based on how many times the user has read books in each genre.
        Only includes published books (where source is not None and published_state is 'published' or None).
        
        Args:
            user_id: The ID of the user
            days: Optional. If provided, only consider books read within this many days
            limit: Maximum number of books to return
            offset: Number of books to skip
            
        Returns:
            List of tuples containing:
            - Book object
            - Total score (sum of genre weights)
            - List of tuples with genre name and score
        """
        # Get user's completed books to exclude from recommendations
        user_completed_subq = (
            self.session.query(BookUser.work_id)
            .filter(
                BookUser.user_id == user_id,
                BookUser.status.in_(["completed", "reading"])
            )
            .subquery()
        )

        # Calculate genre weights based on user's reading history
        user_genre_weights = (
            self.session.query(
                BookGenre.genre_id,
                func.count().label("weight")
            )
            .join(BookUser, BookUser.work_id == BookGenre.work_id)
            .join(Genre, BookGenre.genre_id == Genre.id)
            .filter(
                BookUser.user_id == user_id,
                BookUser.status == "completed",
                Genre.name != "Audiobook"
            )
        )
        
        # Add date filter if days parameter is provided
        if days is not None:
            cutoff_date = datetime.utcnow() - timedelta(days=days)
            user_genre_weights = user_genre_weights.filter(BookUser.finished_at >= cutoff_date)
            
        user_genre_weights = user_genre_weights.group_by(BookGenre.genre_id).subquery()

        # Main query: unread books (i.e. not in user_completed_subq)
        # Join with BookGenre and the user_genre_weights to calculate a total score per book.
        query = (
            self.session.query(
                Book,
                func.sum(user_genre_weights.c.weight).label("total_score")
            )
            .join(BookGenre, Book.work_id == BookGenre.work_id)
            .join(user_genre_weights, BookGenre.genre_id == user_genre_weights.c.genre_id)
            .join(Genre, BookGenre.genre_id == Genre.id)
            .filter(
                ~Book.work_id.in_(user_completed_subq),
                Genre.name != "Audiobook",
                Book.source != None,  # Only include published books
                or_(
                    Book.published_state == "published",
                    Book.published_state == None
                )
            )
            .options(
                joinedload(Book.book_authors).joinedload(BookAuthor.author),
                joinedload(Book.book_series).joinedload(BookSeries.series),
                joinedload(Book.book_wanted)
            )
            .group_by(Book.work_id)
            .having(func.sum(user_genre_weights.c.weight) > 0)
            .order_by(desc("total_score"), desc(Book.goodreads_votes))
            .offset(offset)
            .limit(limit)
        )

        results = query.all()

        recommended_books = []
        # For each recommended book, get a breakdown of genre scores
        for book, total_score in results:
            breakdown = (
                self.session.query(
                    Genre.name,
                    user_genre_weights.c.weight
                )
                .join(BookGenre, Genre.id == BookGenre.genre_id)
                .join(user_genre_weights, BookGenre.genre_id == user_genre_weights.c.genre_id)
                .filter(BookGenre.work_id == book.work_id, Genre.name != "Audiobook")
                .all()
            )
            # Sort breakdown by weight descending then alphabetically by genre name
            genre_breakdown = sorted(breakdown, key=lambda x: (-x[1], x[0]))
            recommended_books.append((book, total_score, genre_breakdown))

        return recommended_books

    def get_on_deck_books(self, user_id: int, limit: int = 20, offset: int = 0) -> List[Book]:
        """
        Get books that are 'on deck' for the user to read next.
        This includes:
        1. Books currently being read
        2. Next unread books in series where the user has read previous books,
           ordered by when the user last read a book in each series
        
        Only includes published books (where source is not None and published_state is 'published').
        
        Args:
            user_id: The ID of the user
            limit: Maximum number of books to return
            offset: Number of books to skip
            
        Returns:
            List of Book objects ordered by priority (reading first, then next in series)
        """
        # First, get all books currently being read by the user
        reading_books = (
            self.session.query(Book)
            .join(BookUser)
            .filter(
                BookUser.user_id == user_id,
                BookUser.status == "reading",
                Book.source != None,  # Only include published books
                or_(
                    Book.published_state == "published",
                    Book.published_state == None
                )
            )
            .options(
                joinedload(Book.book_authors).joinedload(BookAuthor.author),
                joinedload(Book.book_series).joinedload(BookSeries.series),
                joinedload(Book.book_users)
            )
            .all()
        )
        
        print(f"\nFound {len(reading_books)} books currently being read")
        for book in reading_books:
            print(f"Currently reading: {book.title}")
        
        # Get all series where the user has read at least one book, ordered by last read date
        read_series = (
            self.session.query(Series, func.max(BookUser.finished_at).label('last_read'))
            .join(BookSeries)
            .join(Book)
            .join(BookUser)
            .filter(
                BookUser.user_id == user_id,
                BookUser.status == "completed",
                Book.source != None,  # Only include published books
                or_(
                    Book.published_state == "published",
                    Book.published_state == None
                )
            )
            .group_by(Series)
            .order_by(desc('last_read'))
            .all()
        )
        
        print(f"\nFound {len(read_series)} series with completed books")
        
        # For each series, get the next unread book
        next_in_series_books = []
        for series, last_read in read_series:
            # Get the highest series_order of completed books in this series
            max_completed_order = (
                self.session.query(func.max(BookSeries.series_order))
                .join(Book)
                .join(BookUser)
                .filter(
                    BookSeries.series.has(goodreads_id=series.goodreads_id),
                    BookUser.user_id == user_id,
                    BookUser.status == "completed",
                    Book.source != None,  # Only include published books
                    or_(
                        Book.published_state == "published",
                        Book.published_state == None
                    )
                )
                .scalar() or 0
            )
            
            # Get the next book in the series that hasn't been read
            next_book = (
                self.session.query(Book)
                .join(BookSeries)
                .outerjoin(BookUser, and_(
                    BookUser.work_id == Book.work_id,
                    BookUser.user_id == user_id
                ))
                .filter(
                    BookSeries.series.has(goodreads_id=series.goodreads_id),
                    BookSeries.series_order > max_completed_order,
                    Book.source != None,  # Only include published books
                    or_(
                        Book.published_state == "published",
                        Book.published_state == None
                    ),
                    or_(
                        BookUser.work_id == None,  # No entry in book_users
                        and_(
                            BookUser.user_id == user_id,
                            BookUser.status.notin_(["completed", "reading"])
                        )
                    )
                )
                .options(
                    joinedload(Book.book_authors).joinedload(BookAuthor.author),
                    joinedload(Book.book_series).joinedload(BookSeries.series),
                    joinedload(Book.book_users)
                )
                .order_by(BookSeries.series_order)
                .first()
            )
            
            if next_book:
                print(f"\nFound next book in series {series.title}:")
                print(f"  - {next_book.title} (order: {next_book.book_series[0].series_order})")
                print(f"  - Last book in series read: {last_read}")
                next_in_series_books.append(next_book)
        
        # Combine and deduplicate the results
        all_books = reading_books + next_in_series_books
        unique_books = list(dict.fromkeys(all_books))  # Preserve order while deduplicating
        
        # Apply pagination
        paginated_books = unique_books[offset:offset + limit]
        
        return paginated_books

    def add_wanted_book(self, user_id: int, work_id: str, source: str = "manual") -> Optional[BookWanted]:
        """Add a book to the user's wanted list.
        
        Args:
            user_id: The ID of the user
            work_id: The work ID of the book to add
            source: Where the book will be acquired from (default: "manual")
            
        Returns:
            The created BookWanted entry if successful, None if the book doesn't exist
            
        Raises:
            ValueError: If:
                1. The book is already in the user's wanted list (prevents duplicates)
                2. The book exists in the library (can't want what you already have)
        """
        # Validation 1: Check if the book exists in our books table
        # We can't want a book that we don't know about
        book = self.session.query(Book).filter(Book.work_id == work_id).first()
        if not book:
            return None
            
        # Validation 2: Check if already in wanted list
        # Prevents duplicate entries for the same book
        existing = (
            self.session.query(BookWanted)
            .filter(
                BookWanted.user_id == user_id,
                BookWanted.work_id == work_id
            )
            .first()
        )
        if existing:
            raise ValueError(f"Book {work_id} is already in user's wanted list")

        # Validation 3: Check if book exists in library
        # Can't want a book that's already in the library
        library_entry = (
            self.session.query(Library)
            .filter(Library.work_id == work_id)
            .first()
        )
        if library_entry:
            raise ValueError(f"Book {work_id} already exists in the library and cannot be marked as wanted")
            
        # All validations passed, create new wanted entry
        wanted = BookWanted(
            user_id=user_id,
            work_id=work_id,
            source=source
        )
        self.session.add(wanted)
        
        try:
            self.session.commit()
            return wanted
        except Exception as e:
            self.session.rollback()
            raise ValueError(f"Error adding book to wanted list: {str(e)}")

    def remove_wanted_book(self, user_id: int, work_id: str) -> bool:
        """Remove a book from the user's wanted list.
        
        Args:
            user_id: The ID of the user
            work_id: The work ID of the book to remove
            
        Returns:
            True if the book was removed, False if it wasn't in the wanted list
        """
        result = (
            self.session.query(BookWanted)
            .filter(
                BookWanted.user_id == user_id,
                BookWanted.work_id == work_id
            )
            .delete()
        )
        self.session.commit()
        return result > 0

    def get_wanted_books(
        self,
        user_id: int,
        limit: int = 20,
        offset: int = 0
    ) -> List[tuple[BookWanted, Book]]:
        """Get a user's wanted books with full book information.
        
        Args:
            user_id: The ID of the user
            limit: Maximum number of results to return
            offset: Number of records to skip
            
        Returns:
            List of tuples containing (BookWanted, Book) pairs
        """
        return (
            self.session.query(BookWanted, Book)
            .join(Book, BookWanted.work_id == Book.work_id)
            .filter(BookWanted.user_id == user_id)
            .options(
                joinedload(Book.book_authors).joinedload(BookAuthor.author),
                joinedload(Book.book_series).joinedload(BookSeries.series)
            )
            .order_by(BookWanted.created_at.desc())
            .offset(offset)
            .limit(limit)
            .all()
        )

    # Subscription Management Methods
    
    def subscribe_to_author(self, user_id: int, author_goodreads_id: str) -> Optional[UserAuthorSubscription]:
        """Subscribe a user to an author.
        
        Args:
            user_id: The ID of the user
            author_goodreads_id: The Goodreads ID of the author
            
        Returns:
            The created subscription if successful, None if the author doesn't exist
            
        Raises:
            ValueError: If the user is already subscribed to this author
        """
        # Check if author exists
        author = self.session.query(Author).filter(Author.goodreads_id == author_goodreads_id).first()
        if not author:
            return None
            
        # Check for existing subscription
        existing = (
            self.session.query(UserAuthorSubscription)
            .filter(
                UserAuthorSubscription.user_id == user_id,
                UserAuthorSubscription.author_goodreads_id == author_goodreads_id,
                UserAuthorSubscription.deleted_at.is_(None)  # Not soft deleted
            )
            .first()
        )
        if existing:
            raise ValueError(f"Already subscribed to author {author_goodreads_id}")
            
        # Create new subscription
        subscription = UserAuthorSubscription(
            user_id=user_id,
            author_goodreads_id=author_goodreads_id
        )
        self.session.add(subscription)
        
        try:
            self.session.commit()
            return subscription
        except Exception as e:
            self.session.rollback()
            raise ValueError(f"Error creating author subscription: {str(e)}")
            
    def subscribe_to_series(self, user_id: int, series_goodreads_id: str) -> Optional[UserSeriesSubscription]:
        """Subscribe a user to a series.
        
        Args:
            user_id: The ID of the user
            series_goodreads_id: The Goodreads ID of the series
            
        Returns:
            The created subscription if successful, None if the series doesn't exist
            
        Raises:
            ValueError: If the user is already subscribed to this series
        """
        # Check if series exists
        series = self.session.query(Series).filter(Series.goodreads_id == series_goodreads_id).first()
        if not series:
            return None
            
        # Check for existing subscription
        existing = (
            self.session.query(UserSeriesSubscription)
            .filter(
                UserSeriesSubscription.user_id == user_id,
                UserSeriesSubscription.series_goodreads_id == series_goodreads_id,
                UserSeriesSubscription.deleted_at.is_(None)  # Not soft deleted
            )
            .first()
        )
        if existing:
            raise ValueError(f"Already subscribed to series {series_goodreads_id}")
            
        # Create new subscription
        subscription = UserSeriesSubscription(
            user_id=user_id,
            series_goodreads_id=series_goodreads_id
        )
        self.session.add(subscription)
        
        try:
            self.session.commit()
            return subscription
        except Exception as e:
            self.session.rollback()
            raise ValueError(f"Error creating series subscription: {str(e)}")
            
    def unsubscribe_from_author(self, user_id: int, author_goodreads_id: str, hard_delete: bool = False) -> bool:
        """Unsubscribe a user from an author.
        
        Args:
            user_id: The ID of the user
            author_goodreads_id: The Goodreads ID of the author
            hard_delete: If True, removes the record; if False, soft deletes (default: False)
            
        Returns:
            True if unsubscribed successfully, False if subscription not found
        """
        subscription = (
            self.session.query(UserAuthorSubscription)
            .filter(
                UserAuthorSubscription.user_id == user_id,
                UserAuthorSubscription.author_goodreads_id == author_goodreads_id,
                UserAuthorSubscription.deleted_at.is_(None)  # Not already soft deleted
            )
            .first()
        )
        
        if not subscription:
            return False
            
        if hard_delete:
            self.session.delete(subscription)
        else:
            subscription.deleted_at = datetime.now(UTC)
            
        self.session.commit()
        return True
        
    def unsubscribe_from_series(self, user_id: int, series_goodreads_id: str, hard_delete: bool = False) -> bool:
        """Unsubscribe a user from a series.
        
        Args:
            user_id: The ID of the user
            series_goodreads_id: The Goodreads ID of the series
            hard_delete: If True, removes the record; if False, soft deletes (default: False)
            
        Returns:
            True if unsubscribed successfully, False if subscription not found
        """
        subscription = (
            self.session.query(UserSeriesSubscription)
            .filter(
                UserSeriesSubscription.user_id == user_id,
                UserSeriesSubscription.series_goodreads_id == series_goodreads_id,
                UserSeriesSubscription.deleted_at.is_(None)  # Not already soft deleted
            )
            .first()
        )
        
        if not subscription:
            return False
            
        if hard_delete:
            self.session.delete(subscription)
        else:
            subscription.deleted_at = datetime.now(UTC)
            
        self.session.commit()
        return True
        
    def restore_author_subscription(self, user_id: int, author_goodreads_id: str) -> bool:
        """Restore a soft-deleted author subscription.
        
        Args:
            user_id: The ID of the user
            author_goodreads_id: The Goodreads ID of the author
            
        Returns:
            True if restored successfully, False if subscription not found or not soft-deleted
        """
        subscription = (
            self.session.query(UserAuthorSubscription)
            .filter(
                UserAuthorSubscription.user_id == user_id,
                UserAuthorSubscription.author_goodreads_id == author_goodreads_id,
                UserAuthorSubscription.deleted_at.isnot(None)  # Must be soft deleted
            )
            .first()
        )
        
        if not subscription:
            return False
            
        subscription.deleted_at = None
        self.session.commit()
        return True
        
    def restore_series_subscription(self, user_id: int, series_goodreads_id: str) -> bool:
        """Restore a soft-deleted series subscription.
        
        Args:
            user_id: The ID of the user
            series_goodreads_id: The Goodreads ID of the series
            
        Returns:
            True if restored successfully, False if subscription not found or not soft-deleted
        """
        subscription = (
            self.session.query(UserSeriesSubscription)
            .filter(
                UserSeriesSubscription.user_id == user_id,
                UserSeriesSubscription.series_goodreads_id == series_goodreads_id,
                UserSeriesSubscription.deleted_at.isnot(None)  # Must be soft deleted
            )
            .first()
        )
        
        if not subscription:
            return False
            
        subscription.deleted_at = None
        self.session.commit()
        return True
        
    def get_author_subscriptions(
        self,
        user_id: int,
        include_deleted: bool = False,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> List[tuple[UserAuthorSubscription, Author]]:
        """Get a user's author subscriptions with full author information.
        
        Args:
            user_id: The ID of the user
            include_deleted: Whether to include soft-deleted subscriptions (default: False)
            limit: Maximum number of results to return
            offset: Number of records to skip
            
        Returns:
            List of tuples containing (UserAuthorSubscription, Author) pairs
        """
        query = (
            self.session.query(UserAuthorSubscription, Author)
            .join(Author, UserAuthorSubscription.author_goodreads_id == Author.goodreads_id)
            .filter(UserAuthorSubscription.user_id == user_id)
        )
        
        if not include_deleted:
            query = query.filter(UserAuthorSubscription.deleted_at.is_(None))
            
        query = query.order_by(UserAuthorSubscription.created_at.desc())
        
        if offset is not None:
            query = query.offset(offset)
        if limit is not None:
            query = query.limit(limit)
            
        return query.all()
        
    def get_series_subscriptions(
        self,
        user_id: int,
        include_deleted: bool = False,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> List[tuple[UserSeriesSubscription, Series]]:
        """Get a user's series subscriptions with full series information.
        
        Args:
            user_id: The ID of the user
            include_deleted: Whether to include soft-deleted subscriptions (default: False)
            limit: Maximum number of results to return
            offset: Number of records to skip
            
        Returns:
            List of tuples containing (UserSeriesSubscription, Series) pairs
        """
        query = (
            self.session.query(UserSeriesSubscription, Series)
            .join(Series, UserSeriesSubscription.series_goodreads_id == Series.goodreads_id)
            .filter(UserSeriesSubscription.user_id == user_id)
        )
        
        if not include_deleted:
            query = query.filter(UserSeriesSubscription.deleted_at.is_(None))
            
        query = query.order_by(UserSeriesSubscription.created_at.desc())
        
        if offset is not None:
            query = query.offset(offset)
        if limit is not None:
            query = query.limit(limit)
            
        return query.all()
        
    def is_subscribed_to_author(self, user_id: int, author_goodreads_id: str, include_deleted: bool = False) -> bool:
        """Check if a user is subscribed to an author.
        
        Args:
            user_id: The ID of the user
            author_goodreads_id: The Goodreads ID of the author
            include_deleted: Whether to include soft-deleted subscriptions (default: False)
            
        Returns:
            True if subscribed, False otherwise
        """
        query = (
            self.session.query(UserAuthorSubscription)
            .filter(
                UserAuthorSubscription.user_id == user_id,
                UserAuthorSubscription.author_goodreads_id == author_goodreads_id
            )
        )
        
        if not include_deleted:
            query = query.filter(UserAuthorSubscription.deleted_at.is_(None))
            
        return query.first() is not None
        
    def is_subscribed_to_series(self, user_id: int, series_goodreads_id: str, include_deleted: bool = False) -> bool:
        """Check if a user is subscribed to a series.
        
        Args:
            user_id: The ID of the user
            series_goodreads_id: The Goodreads ID of the series
            include_deleted: Whether to include soft-deleted subscriptions (default: False)
            
        Returns:
            True if subscribed, False otherwise
        """
        query = (
            self.session.query(UserSeriesSubscription)
            .filter(
                UserSeriesSubscription.user_id == user_id,
                UserSeriesSubscription.series_goodreads_id == series_goodreads_id
            )
        )
        
        if not include_deleted:
            query = query.filter(UserSeriesSubscription.deleted_at.is_(None))
            
        return query.first() is not None

    def get_series_books_with_user_status(
        self,
        user_id: int,
        series_goodreads_id: str
    ) -> List[Book]:
        """Get all books in a series with their read status for a user.
        
        Args:
            user_id: The ID of the user
            series_goodreads_id: The Goodreads ID of the series
            
        Returns:
            List of Book objects with loaded relationships, ordered by series position
        """
        return (
            self.session.query(Book)
            .join(BookSeries)
            .filter(BookSeries.series_id == series_goodreads_id)
            .options(
                joinedload(Book.book_authors).joinedload(BookAuthor.author),
                joinedload(Book.book_series).joinedload(BookSeries.series),
                joinedload(Book.book_users)
            )
            .order_by(BookSeries.series_order)
            .all()
        )

    def get_series_books(self, series_id: str) -> List[Book]:
        """Get the first three books in a series by release date.
        
        Args:
            series_id: The Goodreads ID of the series
            
        Returns:
            List of up to three Book objects, ordered by published_date
        """
        return (
            self.session.query(Book)
            .join(BookSeries)
            .filter(BookSeries.series.has(goodreads_id=series_id))
            .order_by(Book.published_date)
            .all()
        )

    def get_series_author_id(self, series_id: str) -> Optional[str]:
        """Get the Goodreads ID of the author of the first book in a series.
        
        Args:
            series_id: The Goodreads ID of the series
            
        Returns:
            The author's Goodreads ID if found, None otherwise
        """
        first_book = (
            self.session.query(Book)
            .join(BookSeries)
            .join(BookAuthor)
            .filter(
                BookSeries.series.has(goodreads_id=series_id),
                BookAuthor.role == "Author"
            )
            .order_by(Book.published_date)
            .first()
        )
        
        if first_book and first_book.book_authors:
            for ba in first_book.book_authors:
                if ba.role == "Author":
                    return ba.author.goodreads_id
        return None 


# core/sa/repositories/__init__.py
from .book import BookRepository
from .author import AuthorRepository

__all__ = ['BookRepository', 'AuthorRepository']

