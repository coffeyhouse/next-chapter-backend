# core/sa/models/author.py
from datetime import datetime, UTC
from sqlalchemy import Column, String, DateTime
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin, LastSyncedMixin

class Author(Base, TimestampMixin, LastSyncedMixin):
    __tablename__ = 'author'

    goodreads_id: Mapped[str] = mapped_column(String, primary_key=True)
    name: Mapped[str] = mapped_column(String, nullable=False)
    bio: Mapped[str | None] = mapped_column(String, nullable=True)
    image_url: Mapped[str | None] = mapped_column(String, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

    # Relationships
    book_authors = relationship('BookAuthor', back_populates='author')
    
    # Convenience relationship
    books = relationship('Book', secondary='book_author', viewonly=True)
    user_subscriptions = relationship('UserAuthorSubscription', back_populates='author')


# core\sa\models\base.py

from datetime import datetime, UTC
from sqlalchemy.orm import DeclarativeBase, mapped_column, Mapped
from sqlalchemy import DateTime

class Base(DeclarativeBase):
    """Base class for all models"""
    pass

class TimestampMixin:
    """Mixin to add created_at and updated_at columns"""
    created_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

class LastSyncedMixin:
    """Mixin to add last_synced_at column"""
    last_synced_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)


# core/sa/models/book.py
from datetime import datetime
from sqlalchemy import String, Integer, Float, Boolean, ForeignKey, Table, DateTime
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin, LastSyncedMixin
from enum import Enum

class HiddenReason(str, Enum):
    # Vote/Data Quality
    LOW_VOTE_COUNT = "low_vote_count"           # Too few votes to be reliable
    NO_DESCRIPTION = "no_description"           # Missing book description
    EXCEEDS_PAGE_LENGTH = "exceeds_page_length" # Page count too high
    PAGE_COUNT_UNKNOWN = "page_count_unknown"   # Missing page count

    # Language
    NO_ENGLISH_EDITIONS = "no_english_editions" # No English editions found

    # Excluded Format/Genre
    EXCLUDED_GENRE = "excluded_genre"           # Book in an excluded genre (manga, etc)
    INVALID_FORMAT = "invalid_format"           # Invalid book format

    # Title Issues
    TITLE_PATTERN_MATCH = "title_pattern_match"     # Title contains excluded pattern
    TITLE_NUMBER_PATTERN = "title_number_pattern"   # Title contains number pattern
    COMBINED_EDITION = "combined_edition"           # Book is a combined edition of multiple books

    # Publication Info
    INVALID_PUBLICATION = "invalid_publication" # Invalid or missing publication info
    
    # Manually hidden by user
    MANUAL = "manual"        # Manually hidden by user

class BookAuthor(Base, TimestampMixin):
    __tablename__ = 'book_author'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    author_id: Mapped[str] = mapped_column(ForeignKey('author.goodreads_id'), primary_key=True)
    role: Mapped[str | None] = mapped_column(String, nullable=True)

    # Relationships
    book = relationship('Book', back_populates='book_authors')
    author = relationship('Author', back_populates='book_authors')

class BookGenre(Base, TimestampMixin):
    __tablename__ = 'book_genre'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    genre_id: Mapped[int] = mapped_column(ForeignKey('genre.id'), primary_key=True)

    # Relationships
    book = relationship('Book', back_populates='book_genres')
    genre = relationship('Genre', back_populates='book_genres')

class BookSimilar(Base, TimestampMixin):
    __tablename__ = 'book_similar'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    similar_work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)

    # Relationships
    book = relationship('Book', foreign_keys=[work_id], back_populates='similar_to')
    similar_book = relationship('Book', foreign_keys=[similar_work_id], back_populates='similar_books')

class BookScraped(Base, TimestampMixin):
    """Reference table for tracking which Goodreads IDs have been scraped and their work IDs"""
    __tablename__ = 'book_scraped'

    goodreads_id: Mapped[str] = mapped_column(String, primary_key=True)
    work_id: Mapped[str | None] = mapped_column(ForeignKey('book.work_id'), nullable=True)
    book = relationship('Book', back_populates='book_scraped', foreign_keys=[work_id])

class Book(Base, TimestampMixin, LastSyncedMixin):
    __tablename__ = 'book'

    goodreads_id: Mapped[str] = mapped_column(String, primary_key=True)
    work_id: Mapped[str] = mapped_column(String, unique=True, nullable=False)
    title: Mapped[str] = mapped_column(String, nullable=False)
    published_date: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
    published_state: Mapped[str | None] = mapped_column(String, nullable=True)
    pages: Mapped[int | None] = mapped_column(Integer, nullable=True)
    goodreads_rating: Mapped[float | None] = mapped_column(Float, nullable=True)
    goodreads_votes: Mapped[int | None] = mapped_column(Integer, nullable=True)
    description: Mapped[str | None] = mapped_column(String, nullable=True)
    image_url: Mapped[str | None] = mapped_column(String, nullable=True)
    source: Mapped[str | None] = mapped_column(String, nullable=True)
    hidden: Mapped[bool] = mapped_column(Boolean, default=False)
    hidden_reason: Mapped[str | None] = mapped_column(String, nullable=True)
    similar_synced_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
    scraping_priority: Mapped[int | None] = mapped_column(Integer, nullable=True)
    next_scrape_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)

    # Relationships
    book_authors = relationship('BookAuthor', back_populates='book')
    book_genres = relationship('BookGenre', back_populates='book')
    book_users = relationship('BookUser', back_populates='book')
    book_wanted = relationship('BookWanted', back_populates='book')
    book_series = relationship('BookSeries', back_populates='book')
    library_entries = relationship('Library', back_populates='book')
    similar_to = relationship('BookSimilar', foreign_keys=[BookSimilar.work_id], back_populates='book')
    similar_books = relationship('BookSimilar', foreign_keys=[BookSimilar.similar_work_id], back_populates='similar_book')
    book_scraped = relationship('BookScraped', back_populates='book')

    # Convenience relationships
    authors = relationship('Author', secondary='book_author', viewonly=True)
    genres = relationship('Genre', secondary='book_genre', viewonly=True)
    users = relationship('User', secondary='book_user', viewonly=True)
    series = relationship('Series', secondary='book_series', viewonly=True)


# core/sa/models/genre.py
from sqlalchemy import Integer, String
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin

class Genre(Base, TimestampMixin):
    __tablename__ = 'genre'

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String, nullable=False, unique=True)

    # Relationships
    book_genres = relationship('BookGenre', back_populates='genre')
    
    # Convenience relationship
    books = relationship('Book', secondary='book_genre', viewonly=True)


# core/sa/models/library.py
from sqlalchemy import Integer, String, ForeignKey
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin, LastSyncedMixin

class Library(Base, TimestampMixin, LastSyncedMixin):
    __tablename__ = 'library'

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    title: Mapped[str] = mapped_column(String, nullable=False)
    calibre_id: Mapped[int | None] = mapped_column(Integer, nullable=True)
    goodreads_id: Mapped[str | None] = mapped_column(String, unique=True, nullable=True)
    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), nullable=False)
    isbn: Mapped[str | None] = mapped_column(String, nullable=True)

    # Relationships
    book = relationship('Book', back_populates='library_entries')


# core/sa/models/series.py
from sqlalchemy import String, Float, ForeignKey, DateTime
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin, LastSyncedMixin
from datetime import datetime, UTC

class BookSeries(Base, TimestampMixin):
    """Association model for books in series"""
    __tablename__ = 'book_series'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    series_id: Mapped[str] = mapped_column(ForeignKey('series.goodreads_id'), primary_key=True)
    series_order: Mapped[str | None] = mapped_column(String, nullable=True)

    # Relationships
    book = relationship('Book', back_populates='book_series')
    series = relationship('Series', back_populates='book_series')

class Series(Base, TimestampMixin, LastSyncedMixin):
    __tablename__ = 'series'

    goodreads_id: Mapped[str] = mapped_column(String, primary_key=True)
    title: Mapped[str] = mapped_column(String, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

    # Relationships
    book_series = relationship('BookSeries', back_populates='series')
    
    # Convenience relationship
    books = relationship('Book', secondary='book_series', viewonly=True)
    user_subscriptions = relationship('UserSeriesSubscription', back_populates='series')


# core/sa/models/user.py
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, DateTime, UniqueConstraint
from sqlalchemy.orm import relationship, Mapped, mapped_column
from datetime import datetime, UTC
from .base import Base, TimestampMixin
from sqlalchemy.types import TypeDecorator

class SafeDateTime(TypeDecorator):
    """Custom DateTime type that handles empty strings as None"""
    impl = DateTime
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value == '':
            return None
        return value

    def process_result_value(self, value, dialect):
        if value == '':
            return None
        return value

class BookUser(Base, TimestampMixin):
    __tablename__ = 'book_user'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('user.id'), primary_key=True)
    status: Mapped[str] = mapped_column(String)
    source: Mapped[str | None] = mapped_column(String, nullable=True)
    started_at: Mapped[datetime | None] = mapped_column(SafeDateTime, nullable=True)
    finished_at: Mapped[datetime | None] = mapped_column(SafeDateTime, nullable=True)
    created_at: Mapped[datetime] = mapped_column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

    # Relationships
    user = relationship('User', back_populates='book_users')
    book = relationship('Book', back_populates='book_users')

    __table_args__ = (
        UniqueConstraint('user_id', 'work_id', name='uix_book_users_user_work'),
    )

class User(Base, TimestampMixin):
    __tablename__ = 'user'

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String, nullable=False, unique=True)
    created_at: Mapped[datetime] = mapped_column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

    # Relationships
    book_users = relationship('BookUser', back_populates='user')
    books = relationship('Book', secondary='book_user', viewonly=True)
    book_wanted = relationship('BookWanted', back_populates='user')
    author_subscriptions = relationship('UserAuthorSubscription', back_populates='user')
    series_subscriptions = relationship('UserSeriesSubscription', back_populates='user')

class BookWanted(Base):
    """Books that users want to acquire."""
    __tablename__ = "book_wanted"
    
    work_id = Column(String, ForeignKey("book.work_id"), primary_key=True)
    user_id = Column(Integer, ForeignKey("user.id"), primary_key=True)
    source = Column(String)  # Where they want to get it from
    created_at = Column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at = Column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))
    
    # Relationships
    user = relationship("User", back_populates="book_wanted")
    book = relationship("Book", back_populates="book_wanted")
    
    __table_args__ = (
        UniqueConstraint('work_id', 'user_id', name='uix_book_wanted_work_user'),
    )

class UserAuthorSubscription(Base):
    """Tracks which authors a user is subscribed to for updates."""
    __tablename__ = "user_author_subscription"
    
    user_id = Column(Integer, ForeignKey("user.id"), primary_key=True)
    author_goodreads_id = Column(String, ForeignKey("author.goodreads_id"), primary_key=True)
    created_at = Column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at = Column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))
    deleted_at = Column(SafeDateTime(timezone=True), nullable=True)
    
    # Relationships
    user = relationship("User", back_populates="author_subscriptions")
    author = relationship("Author", back_populates="user_subscriptions")
    
    __table_args__ = (
        UniqueConstraint('user_id', 'author_goodreads_id', name='uix_user_author_subscription'),
    )

class UserSeriesSubscription(Base):
    """Tracks which series a user is subscribed to for updates."""
    __tablename__ = "user_series_subscription"
    
    user_id = Column(Integer, ForeignKey("user.id"), primary_key=True)
    series_goodreads_id = Column(String, ForeignKey("series.goodreads_id"), primary_key=True)
    created_at = Column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at = Column(SafeDateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))
    deleted_at = Column(SafeDateTime(timezone=True), nullable=True)
    
    # Relationships
    user = relationship("User", back_populates="series_subscriptions")
    series = relationship("Series", back_populates="user_subscriptions")
    
    __table_args__ = (
        UniqueConstraint('user_id', 'series_goodreads_id', name='uix_user_series_subscription'),
    )


# core/sa/models/__init__.py
from .base import Base, TimestampMixin, LastSyncedMixin
from .author import Author
from .genre import Genre
from .series import Series, BookSeries
from .book import Book, BookAuthor, BookGenre, BookSimilar, BookScraped
from .user import User, BookUser, BookWanted, UserAuthorSubscription, UserSeriesSubscription
from .library import Library

__all__ = [
    'Base',
    'TimestampMixin',
    'LastSyncedMixin',
    'Book',
    'BookAuthor',
    'BookGenre',
    'BookSimilar',
    'BookSeries',
    'BookScraped',
    'User',
    'BookUser',
    'BookWanted',
    'UserAuthorSubscription',
    'UserSeriesSubscription',
    'Author',
    'Genre',
    'Series',
    'Library'
]

