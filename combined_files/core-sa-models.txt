# core/sa/models/author.py
from datetime import datetime, UTC
from sqlalchemy import Column, String, DateTime
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin, LastSyncedMixin

class Author(Base, TimestampMixin, LastSyncedMixin):
    __tablename__ = 'author'

    goodreads_id: Mapped[str] = mapped_column(String, primary_key=True)
    name: Mapped[str] = mapped_column(String, nullable=False)
    bio: Mapped[str | None] = mapped_column(String, nullable=True)
    image_url: Mapped[str | None] = mapped_column(String, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

    # Relationships
    book_authors = relationship('BookAuthor', back_populates='author')
    
    # Convenience relationship
    books = relationship('Book', secondary='book_author', viewonly=True)
    user_subscriptions = relationship('UserAuthorSubscription', back_populates='author')


# core\sa\models\base.py

from datetime import datetime, UTC
from sqlalchemy.orm import DeclarativeBase, mapped_column, Mapped
from sqlalchemy import DateTime

class Base(DeclarativeBase):
    """Base class for all models"""
    pass

class TimestampMixin:
    """Mixin to add created_at and updated_at columns"""
    created_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(DateTime, nullable=False, default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

class LastSyncedMixin:
    """Mixin to add last_synced_at column"""
    last_synced_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)


# core/sa/models/book.py
from datetime import datetime
from sqlalchemy import String, Integer, Float, Boolean, ForeignKey, Table, DateTime
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin, LastSyncedMixin

class BookAuthor(Base, TimestampMixin):
    __tablename__ = 'book_author'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    author_id: Mapped[str] = mapped_column(ForeignKey('author.goodreads_id'), primary_key=True)
    role: Mapped[str | None] = mapped_column(String, nullable=True)

    # Relationships
    book = relationship('Book', back_populates='book_authors')
    author = relationship('Author', back_populates='book_authors')

class BookGenre(Base, TimestampMixin):
    __tablename__ = 'book_genre'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    genre_id: Mapped[int] = mapped_column(ForeignKey('genre.id'), primary_key=True)

    # Relationships
    book = relationship('Book', back_populates='book_genres')
    genre = relationship('Genre', back_populates='book_genres')

class BookSimilar(Base, TimestampMixin):
    __tablename__ = 'book_similar'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    similar_work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)

    # Relationships
    book = relationship('Book', foreign_keys=[work_id], back_populates='similar_to')
    similar_book = relationship('Book', foreign_keys=[similar_work_id], back_populates='similar_books')

class BookScraped(Base, TimestampMixin):
    """Reference table for tracking which Goodreads IDs have been scraped and their work IDs"""
    __tablename__ = 'book_scraped'

    goodreads_id: Mapped[str] = mapped_column(String, primary_key=True)
    work_id: Mapped[str | None] = mapped_column(ForeignKey('book.work_id'), nullable=True)
    book = relationship('Book', back_populates='book_scraped', foreign_keys=[work_id])

class Book(Base, TimestampMixin, LastSyncedMixin):
    __tablename__ = 'book'

    goodreads_id: Mapped[str] = mapped_column(String, primary_key=True)
    work_id: Mapped[str] = mapped_column(String, unique=True, nullable=False)
    title: Mapped[str] = mapped_column(String, nullable=False)
    published_date: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
    published_state: Mapped[str | None] = mapped_column(String, nullable=True)
    language: Mapped[str | None] = mapped_column(String, nullable=True)
    calibre_id: Mapped[int | None] = mapped_column(Integer, nullable=True)
    pages: Mapped[int | None] = mapped_column(Integer, nullable=True)
    isbn: Mapped[str | None] = mapped_column(String, nullable=True)
    goodreads_rating: Mapped[float | None] = mapped_column(Float, nullable=True)
    goodreads_votes: Mapped[int | None] = mapped_column(Integer, nullable=True)
    description: Mapped[str | None] = mapped_column(String, nullable=True)
    image_url: Mapped[str | None] = mapped_column(String, nullable=True)
    source: Mapped[str | None] = mapped_column(String, nullable=True)
    hidden: Mapped[bool] = mapped_column(Boolean, default=False)
    similar_synced_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)

    # Relationships
    book_authors = relationship('BookAuthor', back_populates='book')
    book_genres = relationship('BookGenre', back_populates='book')
    book_users = relationship('BookUser', back_populates='book')
    book_wanted = relationship('BookWanted', back_populates='book')
    book_series = relationship('BookSeries', back_populates='book')
    library_entries = relationship('Library', back_populates='book')
    similar_to = relationship('BookSimilar', foreign_keys=[BookSimilar.work_id], back_populates='book')
    similar_books = relationship('BookSimilar', foreign_keys=[BookSimilar.similar_work_id], back_populates='similar_book')
    book_scraped = relationship('BookScraped', back_populates='book')

    # Convenience relationships
    authors = relationship('Author', secondary='book_author', viewonly=True)
    genres = relationship('Genre', secondary='book_genre', viewonly=True)
    users = relationship('User', secondary='book_user', viewonly=True)
    series = relationship('Series', secondary='book_series', viewonly=True)


# core/sa/models/genre.py
from sqlalchemy import Integer, String
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin

class Genre(Base, TimestampMixin):
    __tablename__ = 'genre'

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String, nullable=False, unique=True)

    # Relationships
    book_genres = relationship('BookGenre', back_populates='genre')
    
    # Convenience relationship
    books = relationship('Book', secondary='book_genre', viewonly=True)


# core/sa/models/library.py
from sqlalchemy import Integer, String, ForeignKey
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin, LastSyncedMixin

class Library(Base, TimestampMixin, LastSyncedMixin):
    __tablename__ = 'library'

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    title: Mapped[str] = mapped_column(String, nullable=False)
    calibre_id: Mapped[int | None] = mapped_column(Integer, nullable=True)
    goodreads_id: Mapped[str | None] = mapped_column(String, unique=True, nullable=True)
    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), nullable=False)
    isbn: Mapped[str | None] = mapped_column(String, nullable=True)

    # Relationships
    book = relationship('Book', back_populates='library_entries')


# core/sa/models/series.py
from sqlalchemy import String, Float, ForeignKey, DateTime
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .base import Base, TimestampMixin, LastSyncedMixin
from datetime import datetime, UTC

class BookSeries(Base, TimestampMixin):
    """Association model for books in series"""
    __tablename__ = 'book_series'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    series_id: Mapped[str] = mapped_column(ForeignKey('series.goodreads_id'), primary_key=True)
    series_order: Mapped[float | None] = mapped_column(Float, nullable=True)

    # Relationships
    book = relationship('Book', back_populates='book_series')
    series = relationship('Series', back_populates='book_series')

class Series(Base, TimestampMixin, LastSyncedMixin):
    __tablename__ = 'series'

    goodreads_id: Mapped[str] = mapped_column(String, primary_key=True)
    title: Mapped[str] = mapped_column(String, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

    # Relationships
    book_series = relationship('BookSeries', back_populates='series')
    
    # Convenience relationship
    books = relationship('Book', secondary='book_series', viewonly=True)
    user_subscriptions = relationship('UserSeriesSubscription', back_populates='series')


# core/sa/models/user.py
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, DateTime, UniqueConstraint
from sqlalchemy.orm import relationship, Mapped, mapped_column
from datetime import datetime, UTC
from .base import Base, TimestampMixin

class BookUser(Base, TimestampMixin):
    __tablename__ = 'book_user'

    work_id: Mapped[str] = mapped_column(ForeignKey('book.work_id'), primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('user.id'), primary_key=True)
    status: Mapped[str] = mapped_column(String)
    source: Mapped[str | None] = mapped_column(String, nullable=True)
    started_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
    finished_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

    # Relationships
    user = relationship('User', back_populates='book_users')
    book = relationship('Book', back_populates='book_users')

    __table_args__ = (
        UniqueConstraint('user_id', 'work_id', name='uix_book_users_user_work'),
    )

class User(Base, TimestampMixin):
    __tablename__ = 'user'

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String, nullable=False, unique=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))

    # Relationships
    book_users = relationship('BookUser', back_populates='user')
    books = relationship('Book', secondary='book_user', viewonly=True)
    book_wanted = relationship('BookWanted', back_populates='user')
    author_subscriptions = relationship('UserAuthorSubscription', back_populates='user')
    series_subscriptions = relationship('UserSeriesSubscription', back_populates='user')

class BookWanted(Base):
    """Books that users want to acquire."""
    __tablename__ = "book_wanted"
    
    work_id = Column(String, ForeignKey("book.work_id"), primary_key=True)
    user_id = Column(Integer, ForeignKey("user.id"), primary_key=True)
    source = Column(String)  # Where they want to get it from
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at = Column(DateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))
    
    # Relationships
    user = relationship("User", back_populates="book_wanted")
    book = relationship("Book", back_populates="book_wanted")
    
    __table_args__ = (
        UniqueConstraint('work_id', 'user_id', name='uix_book_wanted_work_user'),
    )

class UserAuthorSubscription(Base):
    """Tracks which authors a user is subscribed to for updates."""
    __tablename__ = "user_author_subscription"
    
    user_id = Column(Integer, ForeignKey("user.id"), primary_key=True)
    author_goodreads_id = Column(String, ForeignKey("author.goodreads_id"), primary_key=True)
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at = Column(DateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))
    deleted_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    user = relationship("User", back_populates="author_subscriptions")
    author = relationship("Author", back_populates="user_subscriptions")
    
    __table_args__ = (
        UniqueConstraint('user_id', 'author_goodreads_id', name='uix_user_author_subscription'),
    )

class UserSeriesSubscription(Base):
    """Tracks which series a user is subscribed to for updates."""
    __tablename__ = "user_series_subscription"
    
    user_id = Column(Integer, ForeignKey("user.id"), primary_key=True)
    series_goodreads_id = Column(String, ForeignKey("series.goodreads_id"), primary_key=True)
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(UTC))
    updated_at = Column(DateTime(timezone=True), default=lambda: datetime.now(UTC), onupdate=lambda: datetime.now(UTC))
    deleted_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    user = relationship("User", back_populates="series_subscriptions")
    series = relationship("Series", back_populates="user_subscriptions")
    
    __table_args__ = (
        UniqueConstraint('user_id', 'series_goodreads_id', name='uix_user_series_subscription'),
    )


# core/sa/models/__init__.py
from .base import Base, TimestampMixin, LastSyncedMixin
from .author import Author
from .genre import Genre
from .series import Series, BookSeries
from .book import Book, BookAuthor, BookGenre, BookSimilar, BookScraped
from .user import User, BookUser, BookWanted, UserAuthorSubscription, UserSeriesSubscription
from .library import Library

__all__ = [
    'Base',
    'TimestampMixin',
    'LastSyncedMixin',
    'Book',
    'BookAuthor',
    'BookGenre',
    'BookSimilar',
    'BookSeries',
    'BookScraped',
    'User',
    'BookUser',
    'BookWanted',
    'UserAuthorSubscription',
    'UserSeriesSubscription',
    'Author',
    'Genre',
    'Series',
    'Library'
]

